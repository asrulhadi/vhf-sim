-----------------------------------------------------------
-- Copyright (c) 2007-2012 Mario Konrad
--
-- All Rights reserved.
-----------------------------------------------------------
-- vhf.lua
-- simrad-rd68
-----------------------------------------------------------

VERSION = 'Simrad RD-68 1.3.0'

-- CONSTANTS {{{

-- Those are all possible events configured for this VHF.
EVENT_0                      = 0x000
EVENT_1                      = 0x001
EVENT_2                      = 0x002
EVENT_3                      = 0x003
EVENT_4                      = 0x004
EVENT_5                      = 0x005
EVENT_6                      = 0x006
EVENT_7                      = 0x007
EVENT_8                      = 0x008
EVENT_9                      = 0x009
EVENT_CANCEL                 = 0x00c
EVENT_ENTER                  = 0x00e
EVENT_LIGHT_PRESS            = 0x010
EVENT_LIGHT_RELEASE          = 0x011
EVENT_TOGGLEPOWER            = 0x012
EVENT_DUALWATCH              = 0x013
EVENT_EMERGENCYFREQ          = 0x014
EVENT_SOFT_0                 = 0x020
EVENT_SOFT_1                 = 0x021
EVENT_SOFT_2                 = 0x022
EVENT_SOFT_3                 = 0x023
EVENT_VOLUME_UP              = 0x030
EVENT_VOLUME_DOWN            = 0x031
EVENT_SQUELCH_UP             = 0x032
EVENT_SQUELCH_DOWN           = 0x033
EVENT_DISTRESS_PRESS         = 0x040
EVENT_DISTRESS_RELEASE       = 0x041
EVENT_DISTRESS_CLOSE_PRESS   = 0x042
EVENT_DISTRESS_CLOSE_RELEASE = 0x043
EVENT_TIMER_NEXT             = 0x079
EVENT_TIMER_LIGHT            = 0x07a
EVENT_TIMER_SEND             = 0x07b
EVENT_TIMER                  = 0x07c
EVENT_GPS                    = 0x07d
EVENT_TIMER_GPS              = 0x07e
EVENT_MSG_RECV               = 0x07f

-- Possible (but not necessarily used) mouse buttons.
MOUSE_LEFT   = 0
MOUSE_MIDDLE = 1
MOUSE_RIGHT  = 2

-- DSC message types. ROUTINE, SAFETY, URGENCY and ALERT are
-- regular messages, the other are for the simulator to handle
-- the communication
DSC_INVALID_TYPE = 0x0000
DSC_ROUTINE      = 0x0001
DSC_SAFETY       = 0x0002
DSC_URGENCY      = 0x0003
DSC_ALERT        = 0x0004
DSC_ACK          = 0x1000

-- This is an enumeration of the destination audience of
-- a DSC message.
DSC_INVALID_RECV = 0x0000
DSC_ALL          = 0x0001
DSC_GROUP        = 0x0002
DSC_INDIVIDUAL   = 0x0003

-- To differentiate between different DSC calls to be made,
-- this enumeration shows all possible types.
-- ROUTINE is used for DSC routine calls with a MMSI from
-- the directory. ROUTINE_IND means the MMSI is entered manually.
-- This does not affect the receiver in any way.
-- It is important to have all "normal" types in the range 0..n-1
-- because of the circular behaviour these types are handled.
-- The special type TYPE_ROUTINE_IND must not be within this range.
TYPE_ROUTINE     =  0
TYPE_SAFETY      =  1
TYPE_URGENCY     =  2
TYPE_GROUP       =  3
TYPE_ROUTINE_IND = 99

-- Registered sounds.
SND_BEEP1         = 0
SND_BEEP2         = 1
SND_BEEP3         = 2
SND_BEEP4         = 3
SND_BEEP5         = 4
SND_BEEP1S        = 5
SND_DISTRESS      = 6
SND_SQUELCH       = 7
SND_RECV_SAFETY   = 8
SND_RECV_URGENCY  = 9
SND_RECV_DISTRESS = 10
SND_BEEP_KEY      = 11
SND_BEEP_ERROR    = 12
NUM_SOUNDS = 13

-- The y coordinates for the different menu entries
-- on the LCD. Those values are in pixels. No absolute
-- coordinates here.
MENU_0 = 11
MENU_1 = 22
MENU_2 = 33
MENU_3 = 44

-- Attribute for displaying text on the LCD.
ALIGN_LEFT   = 0
ALIGN_RIGHT  = 1
ALIGN_MIDDLE = 2

-- Enumeration of the different fonts.
FONT_MENU  = 0
FONT_BIG   = 1
FONT_SMALL = 2
FONT_TIME  = 3

-- Font attributes to control the appearance on the LCD.
FONT_ATTR_NORMAL  = 0
FONT_ATTR_INVERSE = 1

-- All different power stages.
POWER_LO = 0
POWER_HI = 1

-- Names to be displayed on the LCD for the different
-- power stages.
POWER_TEXT = {
	[POWER_LO] = 'Lo',
	[POWER_HI] = 'Hi',
}

-- Output power of the different power stages in units of Watt.
POWER_WATT = {
	[POWER_LO] =  1,
	[POWER_HI] = 25,
}

-- This list contains all events that lead to a key beep.
BEEP_EVENTS = {
	EVENT_0,
	EVENT_1,
	EVENT_2,
	EVENT_3,
	EVENT_4,
	EVENT_5,
	EVENT_6,
	EVENT_7,
	EVENT_8,
	EVENT_9,
	EVENT_CANCEL,
	EVENT_ENTER,
	EVENT_LIGHT_PRESS,
	EVENT_TOGGLEPOWER,
	EVENT_DUALWATCH,
	EVENT_EMERGENCYFREQ,
	EVENT_SOFT_0,
	EVENT_SOFT_1,
	EVENT_SOFT_2,
	EVENT_SOFT_3,
}

-- Boundaries of the sound volume.
VOLUME_OFF =  0
VOLUME_MIN =  1
VOLUME_MAX = 10

-- Constant volumes for key beeps and audio error messages.
VOLUME_KEY   = 0.5
VOLUME_ERROR = 0.5

-- This table defines the gain to be used to control
-- the volume. The gain is not necessarily linear to
-- the volume level. However, the gain must be between
-- 0.0 and 1.0 (inclusive).
VOLUME_GAIN = {
	[ 0] = 0.0,
	[ 1] = 0.1,
	[ 2] = 0.2,
	[ 3] = 0.3,
	[ 4] = 0.4,
	[ 5] = 0.5,
	[ 6] = 0.6,
	[ 7] = 0.7,
	[ 8] = 0.8,
	[ 9] = 0.9,
	[10] = 1.0,
}

-- Boundaries of the squelch values.
SQUELCH_MIN  = 0
SQUELCH_MAX  = 9
SQUELCH_STEP = 5

-- States and boundaries of the background lighting
-- of the LCD.
LIGHT_OFF = 0
LIGHT_MIN = 1
LIGHT_MAX = 5

-- Boundaries of the contrast setting.
CONTRAST_MIN = 0
CONTRAST_MAX = 7

-- Maximum number of entries in the directory.
DIRECTORY_MAX = 16

-- Maximum number of entries in the call log.
CALL_LOG_MAX  = 16

-- Misc time configurations
DISTRESS_RESEND_TIME = 45000  -- 45s
GPS_TIMEOUT          = 30000  -- 30s
CHANNEL_KEY_TIMEOUT  =  4000  --  4s
NAME_KEY_TIMEOUT     =  2000  --  2s

-- Names of the distress alert designations to be displayed
-- on the LCD.
DISTRESS_DESIGNATION = {
	[ 0] = 'Undefined',
	[ 1] = 'Abandoning',
	[ 2] = 'Piracy',
	[ 3] = 'M.O.B.',
	[ 4] = 'Fire',
	[ 5] = 'Flooding',
	[ 6] = 'Collision',
	[ 7] = 'Grounding',
	[ 8] = 'Listing',
	[ 9] = 'Sinking',
	[10] = 'Adrift',
}

-- This is a list of all existing channels and their
-- frequencies (outgoing and incoming frequency).
-- Please note: the outgoing and incoming frequency may
-- differ for non-simplex channels.
CHANNELS_FREQ_SHIP = { --{{{
-- channel   shipTX   coastTX
	[ 1] = { 156.050, 160.650 },
	[ 2] = { 156.100, 160.700 },
	[ 3] = { 156.150, 160.750 },
	[ 4] = { 156.200, 160.800 },
	[ 5] = { 156.250, 160.850 },
	[ 6] = { 156.300, 160.900 },
	[ 7] = { 156.350, 160.950 },
	[ 8] = { 156.400,   0.000 },
	[ 9] = { 156.450, 156.450 },
	[10] = { 156.500, 156.500 },
	[11] = { 156.550, 156.550 },
	[12] = { 156.600, 156.600 },
	[13] = { 156.650, 156.650 },
	[14] = { 156.700, 156.700 },
	[15] = { 156.750, 156.750 },
	[16] = { 156.800, 156.800 },
	[17] = { 156.850, 156.850 },
	[18] = { 156.900, 161.500 },
	[19] = { 156.950, 161.550 },
	[20] = { 157.000, 161.600 },
	[21] = { 157.050, 161.650 },
	[22] = { 157.100, 161.700 },
	[23] = { 157.150, 161.750 },
	[24] = { 157.200, 161.800 },
	[25] = { 157.250, 161.850 },
	[26] = { 157.300, 161.900 },
	[27] = { 157.350, 161.950 },
	[28] = { 157.400, 162.000 },
	[60] = { 156.025, 160.625 },
	[61] = { 156.075, 160.675 },
	[62] = { 156.125, 160.725 },
	[63] = { 156.175, 160.775 },
	[64] = { 156.225, 160.825 },
	[65] = { 156.275, 160.875 },
	[66] = { 156.325, 160.925 },
	[67] = { 156.375, 156.375 },
	[69] = { 156.475, 156.475 },
	[70] = { 156.525, 156.525 },
	[71] = { 156.575, 156.575 },
	[72] = { 156.625,   0.000 },
	[73] = { 156.675, 156.675 },
	[74] = { 156.725, 156.725 },
	[75] = { 156.775, 156.775 },
	[76] = { 156.825, 156.825 },
	[77] = { 156.875,   0.000 },
	[78] = { 156.925, 161.525 },
	[79] = { 156.975, 161.575 },
	[80] = { 157.025, 161.625 },
	[81] = { 157.075, 161.675 },
	[82] = { 157.125, 161.725 },
	[83] = { 157.175, 161.775 },
	[84] = { 157.225, 161.825 },
	[85] = { 157.275, 161.875 },
	[86] = { 157.325, 161.925 },
	[87] = { 157.375, 161.975 },
	[88] = { 157.425, 162.025 },
} --}}}

-- The emergency channel
CHANNEL_EMERGENCY = 16

-- The DSC hailing channel. This channel is used to establish
-- connections.
CHANNEL_DSC       = 70

-- This is a list of all channels to be used as communication
-- channel.
CHANNELS          = {	 1,  2,  3,  4,  5,  6,  7,  8,  9, 10,
						11, 12, 13, 14, 15, 16, 17, 18, 19, 20,
						21, 22, 23, 24, 25, 26, 27, 28,
						60, 61, 62, 63, 64, 65, 66, 67, 68, 69,
						71, 72, 73, 74, 75, 76, 77, 78, 79, 80,
						81, 82, 83, 84, 85, 86, 87, 88
					}

-- A list of all intership channels (simplex) to be used by the VHF
-- to perform DSC routine calls to other sea stations (the caller
-- defines the working channel).
CHANNEL_INTERSHIP = { 6, 8, 9, 10, 12, 13, 15, 16, 17, 67, 69, 72, 73, 77 }

-- All channels with low power output.
CHANNEL_LO_POWER  = { 15, 17, 75, 76 }

-- A list of channel for the speed dial when making a DSC call.
CHANNEL_SPEED_DIAL = { 6, 8, 72, 77 }

-- This table contains the definintion of letters and numbers to
-- be used when pressing buttons on the keypad. All subsequent
-- characters are used by subsequent presses on the same button.
ENTER_TABLE = {
	[0] = { '0'                     },
	[1] = { ' ', '1'                },
	[2] = { 'A', 'B', 'C', '2'      },
	[3] = { 'D', 'E', 'F', '3'      },
	[4] = { 'G', 'H', 'I', '4'      },
	[5] = { 'J', 'K', 'L', '5'      },
	[6] = { 'M', 'N', 'O', '6'      },
	[7] = { 'P', 'Q', 'R', 'S', '7' },
	[8] = { 'T', 'U', 'V', '8'      },
	[9] = { 'W', 'X', 'Y', 'Z', '9' },
}

-- The following (huge) table defines the fonts to be displayed
-- on the LCD.
-- Note: not all characters are defined for all font sizes.
FONT = { --{{{
	[FONT_MENU] = { --{{{
		['A'] = { --{{{
			w = 6, h = 9, d
			=  '      '
			.. ' ###  '
			.. '#   # '
			.. '#   # '
			.. '##### '
			.. '#   # '
			.. '#   # '
			.. '#   # '
			.. '      '
		}, --}}}
		['B'] = { --{{{
			w = 6, h = 9, d
			=  '      '
			.. '####  '
			.. '#   # '
			.. '#   # '
			.. '####  '
			.. '#   # '
			.. '#   # '
			.. '####  '
			.. '      '
		}, --}}}
		['C'] = { --{{{
			w = 6, h = 9, d
			=  '      '
			.. ' ###  '
			.. '#   # '
			.. '#     '
			.. '#     '
			.. '#     '
			.. '#   # '
			.. ' ###  '
			.. '      '
		}, --}}}
		['D'] = { --{{{
			w = 6, h = 9, d
			=  '      '
			.. '###   '
			.. '#  #  '
			.. '#   # '
			.. '#   # '
			.. '#   # '
			.. '#  #  '
			.. '###   '
			.. '      '
		}, --}}}
		['E'] = { --{{{
			w = 6, h = 9, d
			=  '      '
			.. '##### '
			.. '#     '
			.. '#     '
			.. '##### '
			.. '#     '
			.. '#     '
			.. '##### '
			.. '      '
		}, --}}}
		['F'] = { --{{{
			w = 6, h = 9, d
			=  '      '
			.. '##### '
			.. '#     '
			.. '#     '
			.. '####  '
			.. '#     '
			.. '#     '
			.. '#     '
			.. '      '
		}, --}}}
		['G'] = { --{{{
			w = 6, h = 9, d
			=  '      '
			.. ' ###  '
			.. '#   # '
			.. '#     '
			.. '# ### '
			.. '#   # '
			.. '#   # '
			.. ' ###  '
			.. '      '
		}, --}}}
		['H'] = { --{{{
			w = 6, h = 9, d
			=  '      '
			.. '#   # '
			.. '#   # '
			.. '#   # '
			.. '##### '
			.. '#   # '
			.. '#   # '
			.. '#   # '
			.. '      '
		}, --}}}
		['I'] = { --{{{
			w = 6, h = 9, d
			=  '      '
			.. '##### '
			.. '  #   '
			.. '  #   '
			.. '  #   '
			.. '  #   '
			.. '  #   '
			.. '##### '
			.. '      '
		}, --}}}
		['J'] = { --{{{
			w = 6, h = 9, d
			=  '      '
			.. '##### '
			.. '    # '
			.. '    # '
			.. '    # '
			.. '#   # '
			.. '#   # '
			.. ' ###  '
			.. '      '
		}, --}}}
		['K'] = { --{{{
			w = 6, h = 9, d
			=  '      '
			.. '#   # '
			.. '#  #  '
			.. '# #   '
			.. '##    '
			.. '# #   '
			.. '#  #  '
			.. '#   # '
			.. '      '
		}, --}}}
		['L'] = { --{{{
			w = 6, h = 9, d
			=  '      '
			.. '#     '
			.. '#     '
			.. '#     '
			.. '#     '
			.. '#     '
			.. '#     '
			.. '##### '
			.. '      '
		}, --}}}
		['M'] = { --{{{
			w = 6, h = 9, d
			=  '      '
			.. '#   # '
			.. '## ## '
			.. '# # # '
			.. '# # # '
			.. '#   # '
			.. '#   # '
			.. '#   # '
			.. '      '
		}, --}}}
		['N'] = { --{{{
			w = 6, h = 9, d
			=  '      '
			.. '#   # '
			.. '#   # '
			.. '##  # '
			.. '# # # '
			.. '#  ## '
			.. '#   # '
			.. '#   # '
			.. '      '
		}, --}}}
		['O'] = { --{{{
			w = 6, h = 9, d
			=  '      '
			.. ' ###  '
			.. '#   # '
			.. '#   # '
			.. '#   # '
			.. '#   # '
			.. '#   # '
			.. ' ###  '
			.. '      '
		}, --}}}
		['P'] = { --{{{
			w = 6, h = 9, d
			=  '      '
			.. '####  '
			.. '#   # '
			.. '#   # '
			.. '####  '
			.. '#     '
			.. '#     '
			.. '#     '
			.. '      '
		}, --}}}
		['Q'] = { --{{{
			w = 6, h = 9, d
			=  '      '
			.. ' ###  '
			.. '#   # '
			.. '#   # '
			.. '#   # '
			.. '# # # '
			.. '#  #  '
			.. ' ## # '
			.. '      '
		}, --}}}
		['R'] = { --{{{
			w = 6, h = 9, d
			=  '      '
			.. '####  '
			.. '#   # '
			.. '#   # '
			.. '####  '
			.. '# #   '
			.. '#  #  '
			.. '#   # '
			.. '      '
		}, --}}}
		['S'] = { --{{{
			w = 6, h = 9, d
			=  '      '
			.. ' ###  '
			.. '#   # '
			.. '#     '
			.. ' ###  '
			.. '    # '
			.. '#   # '
			.. ' ###  '
			.. '      '
		}, --}}}
		['T'] = { --{{{
			w = 6, h = 9, d
			=  '      '
			.. '##### '
			.. '  #   '
			.. '  #   '
			.. '  #   '
			.. '  #   '
			.. '  #   '
			.. '  #   '
			.. '      '
		}, --}}}
		['U'] = { --{{{
			w = 6, h = 9, d
			=  '      '
			.. '#   # '
			.. '#   # '
			.. '#   # '
			.. '#   # '
			.. '#   # '
			.. '#   # '
			.. ' ###  '
			.. '      '
		}, --}}}
		['V'] = { --{{{
			w = 6, h = 9, d
			=  '      '
			.. '#   # '
			.. '#   # '
			.. '#   # '
			.. '#   # '
			.. '#   # '
			.. ' # #  '
			.. '  #   '
			.. '      '
		}, --}}}
		['W'] = { --{{{
			w = 6, h = 9, d
			=  '      '
			.. '#   # '
			.. '#   # '
			.. '#   # '
			.. '# # # '
			.. '# # # '
			.. '## ## '
			.. '#   # '
			.. '      '
		}, --}}}
		['X'] = { --{{{
			w = 6, h = 9, d
			=  '      '
			.. '#   # '
			.. '#   # '
			.. ' # #  '
			.. '  #   '
			.. ' # #  '
			.. '#   # '
			.. '#   # '
			.. '      '
		}, --}}}
		['Y'] = { --{{{
			w = 6, h = 9, d
			=  '      '
			.. '#   # '
			.. '#   # '
			.. ' # #  '
			.. '  #   '
			.. '  #   '
			.. '  #   '
			.. '  #   '
			.. '      '
		}, --}}}
		['Z'] = { --{{{
			w = 6, h = 9, d
			=  '      '
			.. '##### '
			.. '    # '
			.. '   #  '
			.. '  #   '
			.. ' #    '
			.. '#     '
			.. '##### '
			.. '      '
		}, --}}}
		['a'] = { --{{{
			w = 6, h = 9, d
			=  '      '
			.. '      '
			.. '      '
			.. ' ###  '
			.. '    # '
			.. ' #### '
			.. '#   # '
			.. ' #### '
			.. '      '
		}, --}}}
		['b'] = { --{{{
			w = 6, h = 9, d
			=  '      '
			.. '#     '
			.. '#     '
			.. '# ##  '
			.. '##  # '
			.. '#   # '
			.. '##  # '
			.. '# ##  '
			.. '      '
		}, --}}}
		['c'] = { --{{{
			w = 6, h = 9, d
			=  '      '
			.. '      '
			.. '      '
			.. ' ###  '
			.. '#   # '
			.. '#     '
			.. '#   # '
			.. ' ###  '
			.. '      '
		}, --}}}
		['d'] = { --{{{
			w = 6, h = 9, d
			=  '      '
			.. '    # '
			.. '    # '
			.. ' ## # '
			.. '#  ## '
			.. '#   # '
			.. '#  ## '
			.. ' ## # '
			.. '      '
		}, --}}}
		['e'] = { --{{{
			w = 6, h = 9, d
			=  '      '
			.. '      '
			.. '      '
			.. ' ###  '
			.. '#   # '
			.. '##### '
			.. '#     '
			.. ' ###  '
			.. '      '
		}, --}}}
		['f'] = { --{{{
			w = 6, h = 9, d
			=  '      '
			.. '  ##  '
			.. ' #  # '
			.. ' #    '
			.. '###   '
			.. ' #    '
			.. ' #    '
			.. ' #    '
			.. '      '
		}, --}}}
		['g'] = { --{{{
			w = 6, h = 9, d
			=  '      '
			.. '      '
			.. '      '
			.. ' #### '
			.. '#   # '
			.. ' #### '
			.. '    # '
			.. ' #### '
			.. '      '
		}, --}}}
		['h'] = { --{{{
			w = 6, h = 9, d
			=  '      '
			.. '#     '
			.. '#     '
			.. '#     '
			.. '####  '
			.. '#   # '
			.. '#   # '
			.. '#   # '
			.. '      '
		}, --}}}
		['i'] = { --{{{
			w = 6, h = 9, d
			=  '      '
			.. '  #   '
			.. '      '
			.. ' ##   '
			.. '  #   '
			.. '  #   '
			.. '  #   '
			.. ' ###  '
			.. '      '
		}, --}}}
		['j'] = { --{{{
			w = 6, h = 9, d
			=  '      '
			.. '   #  '
			.. '      '
			.. '  ##  '
			.. '   #  '
			.. '   #  '
			.. ' # #  '
			.. '  #   '
			.. '      '
		}, --}}}
		['k'] = { --{{{
			w = 6, h = 9, d
			=  '      '
			.. '#     '
			.. '#     '
			.. '#  #  '
			.. '# #   '
			.. '##    '
			.. '# #   '
			.. '#  #  '
			.. '      '
		}, --}}}
		['l'] = { --{{{
			w = 6, h = 9, d
			=  '      '
			.. ' ##   '
			.. '  #   '
			.. '  #   '
			.. '  #   '
			.. '  #   '
			.. '  #   '
			.. ' ###  '
			.. '      '
		}, --}}}
		['m'] = { --{{{
			w = 6, h = 9, d
			=  '      '
			.. '      '
			.. '      '
			.. ' # #  '
			.. '# # # '
			.. '# # # '
			.. '# # # '
			.. '# # # '
			.. '      '
		}, --}}}
		['n'] = { --{{{
			w = 6, h = 9, d
			=  '      '
			.. '      '
			.. '      '
			.. '# ##  '
			.. '##  # '
			.. '#   # '
			.. '#   # '
			.. '#   # '
			.. '      '
		}, --}}}
		['o'] = { --{{{
			w = 6, h = 9, d
			=  '      '
			.. '      '
			.. '      '
			.. ' ###  '
			.. '#   # '
			.. '#   # '
			.. '#   # '
			.. ' ###  '
			.. '      '
		}, --}}}
		['p'] = { --{{{
			w = 6, h = 9, d
			=  '      '
			.. '      '
			.. '      '
			.. '####  '
			.. '#   # '
			.. '####  '
			.. '#     '
			.. '#     '
			.. '      '
		}, --}}}
		['q'] = { --{{{
			w = 6, h = 9, d
			=  '      '
			.. '      '
			.. '      '
			.. ' #### '
			.. '#   # '
			.. ' #### '
			.. '    # '
			.. '    # '
			.. '      '
		}, --}}}
		['r'] = { --{{{
			w = 6, h = 9, d
			=  '      '
			.. '      '
			.. '      '
			.. '####  '
			.. '#   # '
			.. '#     '
			.. '#     '
			.. '#     '
			.. '      '
		}, --}}}
		['s'] = { --{{{
			w = 6, h = 9, d
			=  '      '
			.. '      '
			.. '      '
			.. ' #### '
			.. '#     '
			.. ' ###  '
			.. '    # '
			.. '####  '
			.. '      '
		}, --}}}
		['t'] = { --{{{
			w = 6, h = 9, d
			=  '      '
			.. ' #    '
			.. '####  '
			.. ' #    '
			.. ' #    '
			.. ' #    '
			.. ' #    '
			.. '  ##  '
			.. '      '
		}, --}}}
		['u'] = { --{{{
			w = 6, h = 9, d
			=  '      '
			.. '      '
			.. '      '
			.. '#   # '
			.. '#   # '
			.. '#   # '
			.. '#  ## '
			.. ' ## # '
			.. '      '
		}, --}}}
		['v'] = { --{{{
			w = 6, h = 9, d
			=  '      '
			.. '      '
			.. '      '
			.. '#   # '
			.. '#   # '
			.. '#   # '
			.. ' # #  '
			.. '  #   '
			.. '      '
		}, --}}}
		['w'] = { --{{{
			w = 6, h = 9, d
			=  '      '
			.. '      '
			.. '      '
			.. '#   # '
			.. '#   # '
			.. '# # # '
			.. '## ## '
			.. '#   # '
			.. '      '
		}, --}}}
		['x'] = { --{{{
			w = 6, h = 9, d
			=  '      '
			.. '      '
			.. '      '
			.. '#   # '
			.. ' # #  '
			.. '  #   '
			.. ' # #  '
			.. '#   # '
			.. '      '
		}, --}}}
		['y'] = { --{{{
			w = 6, h = 9, d
			=  '      '
			.. '      '
			.. '      '
			.. '#   # '
			.. '#   # '
			.. ' #### '
			.. '    # '
			.. ' ###  '
			.. '      '
		}, --}}}
		['z'] = { --{{{
			w = 6, h = 9, d
			=  '      '
			.. '      '
			.. '      '
			.. '##### '
			.. '   #  '
			.. '  #   '
			.. ' #    '
			.. '##### '
			.. '      '
		}, --}}}
		['0'] = { --{{{
			w = 6, h = 9, d
			=  '      '
			.. ' ###  '
			.. '#   # '
			.. '#  ## '
			.. '# # # '
			.. '##  # '
			.. '#   # '
			.. ' ###  '
			.. '      '
		}, --}}}
		['1'] = { --{{{
			w = 6, h = 9, d
			=  '      '
			.. '  #   '
			.. ' ##   '
			.. '  #   '
			.. '  #   '
			.. '  #   '
			.. '  #   '
			.. ' ###  '
			.. '      '
		}, --}}}
		['2'] = { --{{{
			w = 6, h = 9, d
			=  '      '
			.. ' ###  '
			.. '#   # '
			.. '    # '
			.. ' ###  '
			.. '#     '
			.. '#     '
			.. '##### '
			.. '      '
		}, --}}}
		['3'] = { --{{{
			w = 6, h = 9, d
			=  '      '
			.. ' ###  '
			.. '#   # '
			.. '    # '
			.. ' ###  '
			.. '    # '
			.. '#   # '
			.. ' ###  '
			.. '      '
		}, --}}}
	 	['4'] = { --{{{
			w = 6, h = 9, d
			=  '      '
			.. '#     '
			.. '#  #  '
			.. '#  #  '
			.. '##### '
			.. '   #  '
			.. '   #  '
			.. '   #  '
			.. '      '
		}, --}}}
		['5'] = { --{{{
			w = 6, h = 9, d
			=  '      '
			.. '##### '
			.. '#     '
			.. '#     '
			.. '##### '
			.. '    # '
			.. '    # '
			.. '####  '
			.. '      '
		}, --}}}
		['6'] = { --{{{
			w = 6, h = 9, d
			=  '      '
			.. ' ###  '
			.. '#   # '
			.. '#     '
			.. '####  '
			.. '#   # '
			.. '#   # '
			.. ' ###  '
			.. '      '
		}, --}}}
		['7'] = { --{{{
			w = 6, h = 9, d
			=  '      '
			.. '##### '
			.. '    # '
			.. '   #  '
			.. '  #   '
			.. ' #    '
			.. ' #    '
			.. ' #    '
			.. '      '
		}, --}}}
		['8'] = { --{{{
			w = 6, h = 9, d
			=  '      '
			.. ' ###  '
			.. '#   # '
			.. '#   # '
			.. ' ###  '
			.. '#   # '
			.. '#   # '
			.. ' ###  '
			.. '      '
		}, --}}}
		['9'] = { --{{{
			w = 6, h = 9, d
			=  '      '
			.. ' ###  '
			.. '#   # '
			.. '#   # '
			.. ' #### '
			.. '    # '
			.. '#   # '
			.. ' ###  '
			.. '      '
		}, --}}}
		['up'] = { --{{{
			w = 6, h = 9, d
			=  '      '
			.. '  #   '
			.. '  #   '
			.. ' ###  '
			.. ' ###  '
			.. '##### '
			.. '##### '
			.. '      '
			.. '      '
		}, --}}}
		['down'] = { --{{{
			w = 6, h = 9, d
			=  '      '
			.. '##### '
			.. '##### '
			.. ' ###  '
			.. ' ###  '
			.. '  #   '
			.. '  #   '
			.. '      '
			.. '      '
		}, --}}}
		['left'] = { --{{{
			w = 6, h = 9, d
			=  '      '
			.. '    # '
			.. '   ## '
			.. '  ### '
			.. ' #### '
			.. '  ### '
			.. '   ## '
			.. '    # '
			.. '      '
		}, --}}}
		['right'] = { --{{{
			w = 6, h = 9, d
			=  '      '
			.. '#     '
			.. '##    '
			.. '###   '
			.. '####  '
			.. '###   '
			.. '##    '
			.. '#     '
			.. '      '
		}, --}}}
		['&'] = { --{{{
			w = 6, h = 9, d
			=  '      '
			.. ' ##   '
			.. '#  #  '
			.. ' ##   '
			.. '      '
			.. '      '
			.. '      '
			.. '      '
			.. '      '
		}, --}}}
		[','] = { --{{{
			w = 6, h = 9, d
			=  '      '
			.. '      '
			.. '      '
			.. '      '
			.. '      '
			.. '  ##  '
			.. '   #  '
			.. '   #  '
			.. '      '
		}, --}}}
		['.'] = { --{{{
			w = 6, h = 9, d
			=  '      '
			.. '      '
			.. '      '
			.. '      '
			.. '      '
			.. '      '
			.. '  ##  '
			.. '  ##  '
			.. '      '
		}, --}}}
		[':'] = { --{{{
			w = 6, h = 9, d
			=  '      '
			.. '      '
			.. '      '
			.. '  #   '
			.. '      '
			.. '  #   '
			.. '      '
			.. '      '
			.. '      '
		}, --}}}
		['-'] = { --{{{
			w = 6, h = 9, d
			=  '      '
			.. '      '
			.. '      '
			.. '      '
			.. ' #### '
			.. '      '
			.. '      '
			.. '      '
			.. '      '
		}, --}}}
		['+'] = { --{{{
			w = 6, h = 9, d
			=  '      '
			.. '      '
			.. '  #   '
			.. '  #   '
			.. '##### '
			.. '  #   '
			.. '  #   '
			.. '      '
			.. '      '
		}, --}}}
		['_'] = { --{{{
			w = 6, h = 9, d
			=  '      '
			.. '      '
			.. '      '
			.. '      '
			.. '      '
			.. '      '
			.. '      '
			.. '##### '
			.. '      '
		}, --}}}
		['cursor'] = { --{{{
			w = 6, h = 9, d
			=  '      '
			.. '##### '
			.. '##### '
			.. '##### '
			.. '##### '
			.. '##### '
			.. '##### '
			.. '##### '
			.. '      '
		}, --}}}
		['*'] = { --{{{
			w = 6, h = 9, d
			=  '      '
			.. '  #   '
			.. '# # # '
			.. ' ###  '
			.. '##### '
			.. ' ###  '
			.. '# # # '
			.. '  #   '
			.. '      '
		}, --}}}
		[' '] = { --{{{
			w = 6, h = 9, d
			=  '      '
			.. '      '
			.. '      '
			.. '      '
			.. '      '
			.. '      '
			.. '      '
			.. '      '
			.. '      '
		}, --}}}
		['/'] = { --{{{
			w = 6, h = 9, d
			=  '      '
			.. '    # '
			.. '    # '
			.. '   #  '
			.. '  #   '
			.. ' #    '
			.. '#     '
			.. '#     '
			.. '      '
		}, --}}}
		['\''] = { --{{{
			w = 6, h = 9, d
			=  '      '
			.. '  #   '
			.. '  #   '
			.. '  #   '
			.. '      '
			.. '      '
			.. '      '
			.. '      '
			.. '      '
		}, --}}}
		['?'] = { --{{{
			w = 6, h = 9, d
			=  '      '
			.. ' ###  '
			.. '#   # '
			.. '   #  '
			.. '  #   '
			.. '  #   '
			.. '      '
			.. '  #   '
			.. '      '
		}, --}}}
	}, --}}}
	[FONT_TIME] = { --{{{
		['0'] = { --{{{
			w = 6, h = 6, d
			=  ' ###  '
			.. '#  ## '
			.. '# # # '
			.. '##  # '
			.. ' ###  '
			.. '      '
		}, --}}}
		['1'] = { --{{{
			w = 6, h = 6, d
			=  '  #   '
			.. ' ##   '
			.. '  #   '
			.. '  #   '
			.. ' ###  '
			.. '      '
		}, --}}}
		['2'] = { --{{{
			w = 6, h = 6, d
			=  ' ###  '
			.. '#   # '
			.. '  ##  '
			.. '#     '
			.. '##### '
			.. '      '
		}, --}}}
		['3'] = { --{{{
			w = 6, h = 6, d
			=  ' ###  '
			.. '#   # '
			.. '  ##  '
			.. '#   # '
			.. ' ###  '
			.. '      '
		}, --}}}
		['4'] = { --{{{
			w = 6, h = 6, d
			=  '#     '
			.. '#  #  '
			.. '##### '
			.. '   #  '
			.. '   #  '
			.. '      '
		}, --}}}
		['5'] = { --{{{
			w = 6, h = 6, d
			=  '##### '
			.. '#     '
			.. '##### '
			.. '    # '
			.. '##### '
			.. '      '
		}, --}}}
		['6'] = { --{{{
			w = 6, h = 6, d
			=  ' ###  '
			.. '#     '
			.. '####  '
			.. '#   # '
			.. ' ###  '
			.. '      '
		}, --}}}
		['7'] = { --{{{
			w = 6, h = 6, d
			=  '##### '
			.. '    # '
			.. '   #  '
			.. '  #   '
			.. '  #   '
			.. '      '
		}, --}}}
		['8'] = { --{{{
			w = 6, h = 6, d
			=  ' ###  '
			.. '#   # '
			.. ' ###  '
			.. '#   # '
			.. ' ###  '
			.. '      '
		}, --}}}
		['9'] = { --{{{
			w = 6, h = 9, d
			=  ' ###  '
			.. '#   # '
			.. ' #### '
			.. '    # '
			.. ' ###  '
			.. '      '
		}, --}}}
		[':'] = { --{{{
			w = 6, h = 6, d
			=  '      '
			.. '  #   '
			.. '      '
			.. '  #   '
			.. '      '
			.. '      '
		}, --}}}
		[' '] = { --{{{
			w = 6, h = 6, d
			=  '      '
			.. '      '
			.. '      '
			.. '      '
			.. '      '
			.. '      '
		}, --}}}
		['/'] = { --{{{
			w = 6, h = 6, d
			=  '    # '
			.. '   #  '
			.. '  #   '
			.. ' #    '
			.. '#     '
			.. '      '
		}, --}}}
	}, --}}}
	[FONT_SMALL] = { --{{{
		['0'] = { --{{{
			w = 12, h = 16, d
			=  '            '
			.. '   ######   '
			.. '  ########  '
			.. ' ###    ### '
			.. ' ##    # ## '
			.. ' ##    # ## '
			.. ' ##   #  ## '
			.. ' ##   #  ## '
			.. ' ##  #   ## '
			.. ' ##  #   ## '
			.. ' ## #    ## '
			.. ' ## #    ## '
			.. ' ###    ### '
			.. '  ########  '
			.. '   ######   '
			.. '            '
		}, --}}}
		['1'] = { --{{{
			w = 12, h = 16, d
			=  '            '
			.. '   ####     '
			.. '  ## ##     '
			.. ' ##  ##     '
			.. ' ##  ##     '
			.. '     ##     '
			.. '     ##     '
			.. '     ##     '
			.. '     ##     '
			.. '     ##     '
			.. '     ##     '
			.. '     ##     '
			.. '     ##     '
			.. ' ########## '
			.. ' ########## '
			.. '            '
		}, --}}}
		['2'] = { --{{{
			w = 12, h = 16, d
			=  '            '
			.. '  ########  '
			.. ' ########## '
			.. ' ###    ### '
			.. '         ## '
			.. '         ## '
			.. '       ###  '
			.. '     ###    '
			.. '   ###      '
			.. ' ###        '
			.. ' ##         '
			.. ' ##         '
			.. ' ##         '
			.. ' ########## '
			.. ' ########## '
			.. '            '
		}, --}}}
		['3'] = { --{{{
			w = 12, h = 16, d
			=  '            '
			.. '   ######   '
			.. '  ########  '
			.. ' ###    ### '
			.. '         ## '
			.. '         ## '
			.. '        ### '
			.. '   #######  '
			.. '   #######  '
			.. '        ### '
			.. '         ## '
			.. '         ## '
			.. ' ###    ### '
			.. '  ########  '
			.. '   ######   '
			.. '            '
		}, --}}}
		['4'] = { --{{{
			w = 12, h = 16, d
			=  '            '
			.. ' ##         '
			.. ' ##         '
			.. ' ##         '
			.. ' ##         '
			.. ' ##         '
			.. ' ##  ##     '
			.. ' ##  ##     '
			.. ' ########## '
			.. ' ########## '
			.. '     ##     '
			.. '     ##     '
			.. '     ##     '
			.. '     ##     '
			.. '     ##     '
			.. '            '
		}, --}}}
		['5'] = { --{{{
			w = 12, h = 16, d
			=  '            '
			.. ' ########## '
			.. ' ########## '
			.. ' ##         '
			.. ' ##         '
			.. ' ##         '
			.. ' #########  '
			.. '  ######### '
			.. '         ## '
			.. '         ## '
			.. '         ## '
			.. '         ## '
			.. '         ## '
			.. ' ########## '
			.. ' #########  '
			.. '            '
		}, --}}}
		['6'] = { --{{{
			w = 12, h = 16, d
			=  '            '
			.. '   ######   '
			.. '  ########  '
			.. ' ###     #  '
			.. ' ##         '
			.. ' ##         '
			.. ' ##         '
			.. ' ########   '
			.. ' #########  '
			.. ' ##     ### '
			.. ' ##      ## '
			.. ' ##      ## '
			.. ' ###    ### '
			.. '  ########  '
			.. '   ######   '
			.. '            '
		}, --}}}
		['7'] = { --{{{
			w = 12, h = 16, d
			=  '            '
			.. ' ########## '
			.. ' ########## '
			.. '         ## '
			.. '         ## '
			.. '         ## '
			.. '        ##  '
			.. '       ##   '
			.. '      ##    '
			.. '     ##     '
			.. '     ##     '
			.. '     ##     '
			.. '     ##     '
			.. '     ##     '
			.. '     ##     '
			.. '            '
		}, --}}}
		['8'] = { --{{{
			w = 12, h = 16, d
			=  '            '
			.. '   ######   '
			.. '  ########  '
			.. ' ###    ### '
			.. ' ##      ## '
			.. ' ##      ## '
			.. ' ###    ### '
			.. '  ########  '
			.. '  ########  '
			.. ' ###    ### '
			.. ' ##      ## '
			.. ' ##      ## '
			.. ' ###    ### '
			.. '  ########  '
			.. '   ######   '
			.. '            '
		}, --}}}
		['9'] = { --{{{
			w = 12, h = 16, d
			=  '            '
			.. '   ######   '
			.. '  ########  '
			.. ' ###    ### '
			.. ' ##      ## '
			.. ' ##      ## '
			.. ' ###    ### '
			.. '  ######### '
			.. '   ######## '
			.. '        ### '
			.. '         ## '
			.. '         ## '
			.. '        ### '
			.. '  ########  '
			.. '   ######   '
			.. '            '
		}, --}}}
		[' '] = { --{{{
			w = 12, h = 16, d
			=  '            '
			.. '            '
			.. '            '
			.. '            '
			.. '            '
			.. '            '
			.. '            '
			.. '            '
			.. '            '
			.. '            '
			.. '            '
			.. '            '
			.. '            '
			.. '            '
			.. '            '
			.. '            '
		}, --}}}
	}, --}}}
	[FONT_BIG] = { --{{{
		['0'] = { --{{{
			w = 23, h = 32, d
			=  '                       '
			.. '        #######        '
			.. '     #############     '
			.. '    ###############    '
			.. '   #################   '
			.. '   #####       #####   '
			.. '  #####         #####  '
			.. ' #####           ##### '
			.. ' #####           ##### '
			.. ' #####           ##### '
			.. ' #####           ##### '
			.. ' #####           ##### '
			.. ' #####           ##### '
			.. ' #####           ##### '
			.. ' #####           ##### '
			.. ' #####           ##### '
			.. ' #####           ##### '
			.. ' #####           ##### '
			.. ' #####           ##### '
			.. ' #####           ##### '
			.. ' #####           ##### '
			.. ' #####           ##### '
			.. ' #####           ##### '
			.. ' #####           ##### '
			.. ' #####           ##### '
			.. '  #####         #####  '
			.. '   #####       #####   '
			.. '   #################   '
			.. '    ###############    '
			.. '     #############     '
			.. '        #######        '
			.. '                       '
		}, --}}}
		['1'] = { --{{{
			w = 23, h = 32, d
			=  '                       '
			.. '          ####         '
			.. '         #####         '
			.. '        ######         '
			.. '       #######         '
			.. '      ########         '
			.. '    ##########         '
			.. '   ###########         '
			.. '         #####         '
			.. '         #####         '
			.. '         #####         '
			.. '         #####         '
			.. '         #####         '
			.. '         #####         '
			.. '         #####         '
			.. '         #####         '
			.. '         #####         '
			.. '         #####         '
			.. '         #####         '
			.. '         #####         '
			.. '         #####         '
			.. '         #####         '
			.. '         #####         '
			.. '         #####         '
			.. '         #####         '
			.. '         #####         '
			.. '         #####         '
			.. '         #####         '
			.. '    ###############    '
			.. '    ###############    '
			.. '    ###############    '
			.. '                       '
		}, --}}}
		['2'] = { --{{{
			w = 23, h = 32, d
			=  '                       '
			.. '         #####         '
			.. '      ###########      '
			.. '     #############     '
			.. '    ###############    '
			.. '   ######     ######   '
			.. '   #####       #####   '
			.. '                #####  '
			.. '                #####  '
			.. '                #####  '
			.. '                #####  '
			.. '               #####   '
			.. '              ######   '
			.. '             ######    '
			.. '            ######     '
			.. '           ######      '
			.. '          ######       '
			.. '         ######        '
			.. '        ######         '
			.. '       ######          '
			.. '      ######           '
			.. '     ######            '
			.. '    ######             '
			.. '   ######              '
			.. '  ######               '
			.. ' ######                '
			.. ' #####                 '
			.. ' ##################### '
			.. ' ##################### '
			.. ' ##################### '
			.. ' ##################### '
			.. '                       '
		}, --}}}
		['3'] = { --{{{
			w = 23, h = 32, d
			=  '                       '
			.. '         #####         '
			.. '      ###########      '
			.. '     #############     '
			.. '    ###############    '
			.. '   ######     ######   '
			.. '   #####       #####   '
			.. '   ####         #####  '
			.. '                #####  '
			.. '                #####  '
			.. '                #####  '
			.. '               #####   '
			.. '              ######   '
			.. '         ##########    '
			.. '      ############     '
			.. '      #############    '
			.. '         ###########   '
			.. '               ######  '
			.. '                #####  '
			.. '                 ##### '
			.. '                 ##### '
			.. '                 ##### '
			.. '                 ##### '
			.. '                 ##### '
			.. '  ####           ##### '
			.. '  #####         #####  '
			.. '   #####       #####   '
			.. '   #################   '
			.. '    ###############    '
			.. '     #############     '
			.. '        #######        '
			.. '                       '
		}, --}}}
		['4'] = { --{{{
			w = 23, h = 32, d
			=  '                       '
			.. ' #####                 '
			.. ' #####                 '
			.. ' #####                 '
			.. ' #####                 '
			.. ' #####                 '
			.. ' #####                 '
			.. ' #####                 '
			.. ' #####                 '
			.. ' #####                 '
			.. ' #####                 '
			.. ' #####    #####        '
			.. ' #####    #####        '
			.. ' #####    #####        '
			.. ' ###################   '
			.. ' ###################   '
			.. ' ###################   '
			.. '          #####        '
			.. '          #####        '
			.. '          #####        '
			.. '          #####        '
			.. '          #####        '
			.. '          #####        '
			.. '          #####        '
			.. '          #####        '
			.. '          #####        '
			.. '          #####        '
			.. '          #####        '
			.. '          #####        '
			.. '          #####        '
			.. '          #####        '
			.. '                       '
		}, --}}}
		['5'] = { --{{{
			w = 23, h = 32, d
			=  '                       '
			.. ' ####################  '
			.. ' ####################  '
			.. ' ####################  '
			.. ' #####                 '
			.. ' #####                 '
			.. ' #####                 '
			.. ' #####                 '
			.. ' #####                 '
			.. ' #####                 '
			.. ' #####                 '
			.. ' #####                 '
			.. ' #####                 '
			.. ' ###############       '
			.. ' #################     '
			.. ' ##################    '
			.. ' ###################   '
			.. '               ######  '
			.. '                #####  '
			.. '                 ##### '
			.. '                 ##### '
			.. '                 ##### '
			.. '                 ##### '
			.. '                 ##### '
			.. '                 ##### '
			.. '  #####         #####  '
			.. '  ######       #####   '
			.. '   #################   '
			.. '    ###############    '
			.. '     #############     '
			.. '        #######        '
			.. '                       '
		}, --}}}
		['6'] = { --{{{
			w = 23, h = 32, d
			=  '                       '
			.. '        ######         '
			.. '     ############      '
			.. '    ##############     '
			.. '   #####      #####    '
			.. '  #####        #####   '
			.. '  ####          ####   '
			.. ' #####                 '
			.. ' ####                  '
			.. ' ####                  '
			.. ' ####                  '
			.. ' ####                  '
			.. ' ####                  '
			.. ' ####                  '
			.. ' ####    #######       '
			.. ' ####  ###########     '
			.. ' ##################    '
			.. ' #######       #####   '
			.. ' ######         #####  '
			.. ' #####           ####  '
			.. ' #####           ####  '
			.. ' #####           ####  '
			.. ' #####           ####  '
			.. ' #####           ####  '
			.. ' #####           ####  '
			.. '  #####         #####  '
			.. '   #####       #####   '
			.. '   #################   '
			.. '    ###############    '
			.. '     #############     '
			.. '        #######        '
			.. '                       '
		}, --}}}
		['7'] = { --{{{
			w = 23, h = 32, d
			=  '                       '
			.. ' ##################### '
			.. ' ##################### '
			.. ' ##################### '
			.. '                 ##### '
			.. '                 ##### '
			.. '                #####  '
			.. '               #####   '
			.. '              #####    '
			.. '             #####     '
			.. '            #####      '
			.. '           #####       '
			.. '          #####        '
			.. '         #####         '
			.. '         #####         '
			.. '         #####         '
			.. '         #####         '
			.. '         #####         '
			.. '         #####         '
			.. '         #####         '
			.. '         #####         '
			.. '         #####         '
			.. '         #####         '
			.. '         #####         '
			.. '         #####         '
			.. '         #####         '
			.. '         #####         '
			.. '         #####         '
			.. '         #####         '
			.. '         #####         '
			.. '         #####         '
			.. '                       '
		}, --}}}
		['8'] = { --{{{
			w = 23, h = 32, d
			=  '                       '
			.. '         #####         '
			.. '      ###########      '
			.. '     #############     '
			.. '    ###############    '
			.. '   ######     ######   '
			.. '   #####       #####   '
			.. '  #####         #####  '
			.. '  #####         #####  '
			.. '  #####         #####  '
			.. '  #####         #####  '
			.. '   #####       #####   '
			.. '   ######     ######   '
			.. '    ###############    '
			.. '     #############     '
			.. '    ###############    '
			.. '   #################   '
			.. '  ######       ######  '
			.. '  #####         #####  '
			.. ' #####           ##### '
			.. ' #####           ##### '
			.. ' #####           ##### '
			.. ' #####           ##### '
			.. ' #####           ##### '
			.. ' #####           ##### '
			.. '  #####         #####  '
			.. '   #####       #####   '
			.. '   #################   '
			.. '    ###############    '
			.. '     #############     '
			.. '        #######        '
			.. '                       '
		}, --}}}
		['9'] = { --{{{
			w = 23, h = 32, d
			=  '                       '
			.. '          #####        '
			.. '       ###########     '
			.. '      #############    '
			.. '     ###############   '
			.. '    #####      ######  '
			.. '   #####        #####  '
			.. '   ####          ##### '
			.. '  #####          ##### '
			.. '  #####          ##### '
			.. '  #####          ##### '
			.. '   #####         ##### '
			.. '   ######       ###### '
			.. '    ################## '
			.. '     ################# '
			.. '      ################ '
			.. '                 ##### '
			.. '                 ##### '
			.. '                 ##### '
			.. '                 ##### '
			.. '                 ##### '
			.. '                 ##### '
			.. '                 ##### '
			.. '                 ##### '
			.. '                 ##### '
			.. '                 ####  '
			.. '   ####         ####   '
			.. '   #####       #####   '
			.. '    ###############    '
			.. '     #############     '
			.. '        #######        '
			.. '                       '
		}, --}}}
		[' '] = { --{{{
			w = 23, h = 32, d
			=  '                      '
			.. '                      '
			.. '                      '
			.. '                      '
			.. '                      '
			.. '                      '
			.. '                      '
			.. '                      '
			.. '                      '
			.. '                      '
			.. '                      '
			.. '                      '
			.. '                      '
			.. '                      '
			.. '                      '
			.. '                      '
			.. '                      '
			.. '                      '
			.. '                      '
			.. '                      '
			.. '                      '
			.. '                      '
			.. '                      '
			.. '                      '
			.. '                      '
			.. '                      '
			.. '                      '
			.. '                      '
			.. '                      '
			.. '                      '
			.. '                      '
			.. '                      '
		}, --}}}
	}, --}}}
} --}}}

--}}}

-- GLOBALS {{{
channel = 99
new_channel = -1
dw_channel = 0

volume = VOLUME_OFF
squelch = (SQUELCH_MIN + SQUELCH_MAX) / 2
light = LIGHT_OFF
contrast = 5
power = POWER_HI

da_open = false
wait_for_ack = false
gps_available = false
beep_enable = true

in_exam_mode = false

lcd = {
	w  = 0,
	h  = 0,
	x0 = 0,
	y0 = 0,
	x1 = 0,
	y1 = 0,
	b  = 0,
	npx = 0,
	npy = 0,
	pw = 0,
	ph = 0,
}

mark_vol = {
	x = 0,
	y = 0,
	r = 0,
	phi_min = 0,
	phi_max = 0,
	radius = 0,
	dir = 0,
}

mark_sq = {
	x = 0,
	y = 0,
	r = 0,
	phi_min = 0,
	phi_max = 0,
	radius = 0,
	dir = 0,
}

directory = {}
call_log = {}
last_msg = nil
handling_distress = false

foreground = {}
background = {}
--}}}

-- MISC FUNCTIONS {{{

-- Receives a message from the engine and converts it into a
-- table with individual fields. The memory is also freed
-- for the received message within the engine. The resulting
-- table is under complete control of this script.
function receive_msg()
	local err,msg = msg_recv()
	local m = msg_tab(msg)
	msg_destroy(msg)
	return m
end

-- Returns 'true' if this VHF is the receiver of the
-- specified message.
function i_am_receiver_of(m)
	-- messages to all are processed
	if m.dsc.recv == DSC_ALL then return true end

	-- messages to the group are processed as well
	if m.dsc.recv == DSC_GROUP then
		if mmsi_get_group() == m.dsc.mmsi then
			return true
		end
	end

	-- messages to the own station are processed as well
	if m.dsc.recv == DSC_INDIVIDUAL then
		if mmsi_get_ship() == m.dsc.mmsi then
			return true
		end
	end

	-- ignore all other messages
	return false
end

-- Sets emergency channel and power output.
function set_emerg_ch()
	channel = CHANNEL_EMERGENCY
	power = POWER_HI
end

-- Sets the volume for all sounds except the
-- constant ones (see contstants above).
function handle_volume()
	snd_gain(SND_BEEP1,    VOLUME_GAIN[volume])
	snd_gain(SND_BEEP2,    VOLUME_GAIN[volume])
	snd_gain(SND_BEEP3,    VOLUME_GAIN[volume])
	snd_gain(SND_BEEP4,    VOLUME_GAIN[volume])
	snd_gain(SND_BEEP5,    VOLUME_GAIN[volume])
	snd_gain(SND_BEEP1S,   VOLUME_GAIN[volume])
	snd_gain(SND_DISTRESS, VOLUME_GAIN[volume])
	snd_gain(SND_SQUELCH,  VOLUME_GAIN[volume])
end

-- Handles the squelch. Since this is a simulation,
-- the squelch will be heard at an exact position of
-- of the squelch setting, see SQUELCH_STEP.
function handle_squelch()
	if not is_turned_on() then return end
	handle_volume()
	if squelch > SQUELCH_STEP then
		snd_play(SND_SQUELCH, 1)
	else
		snd_stop(SND_SQUELCH)
	end
end

-- Returns 'true' if the specified element is within
-- the specified table. Otherwise it will return 'false'.
function contains(tab, element)
	for i,e in pairs(tab) do
		if e == element then return true end
	end
	return false
end

function toggle_power()
	-- not possible for certain channels
	if contains(CHANNEL_LO_POWER, channel) then
		power = POWER_LO
	elseif power == POWER_LO then
		power = POWER_HI
	else
		power = POWER_LO
	end
end

function have_pos()
	return gen_vhf_lat_set() and gen_vhf_lon_set()
end

function latitude()
	if gen_vhf_lat_set() then
		local h,d,m = pos_get_lat()
		local side = 'N'
		if h < 0 then
			side = 'S'
		end
		return string.format('%02d&%02d%s', d, m, side)
	else
		return '99&99'
	end
end

function longitude()
	if gen_vhf_lon_set() then
		local h,d,m = pos_get_lon()
		local side = 'W'
		if (h < 0) then
			side = 'E'
		end
		return string.format('%03d&%02d%s', d, m, side)
	else
		return '999&99'
	end
end

function utc()
	if gen_vhf_time_set() then
		local h,m = math.modf(time_get())
		return string.format('%02d:%02d', h, m * 60.0 + 0.5)
	else
		return '88:88'
	end
end

function marker(m, n, value)
	local ps = 0.0
	local phi = 0.0
	if m.phi_min > m.phi_max then
		ps = (360 - m.phi_min + m.phi_max) * math.pi / 180.0 / n;
	elseif m.phi_min < m.phi_max then
		ps = (m.phi_max - m.phi_min) * math.pi / 180.0 / n;
	else
		ps = 2.0 * math.pi / n
	end
	if m.dir > 0 then
		phi = math.pi + m.phi_max * math.pi / 180.0 - value * ps
	else
		phi = math.pi + m.phi_min * math.pi / 180.0 + value * ps
	end
	local x = m.x + m.r * math.sin(phi)
	local y = m.y + m.r * math.cos(phi)
	draw_set_pen(0xa0, 0xa0, 0xa0)
	draw_set_brush(0x60, 0x60, 0x60)
	draw_circ(x, y, m.radius)
end

function marker_volume()
	marker(mark_vol, VOLUME_MAX - VOLUME_OFF, volume)
end

function marker_squelch()
	marker(mark_sq, SQUELCH_MAX - SQUELCH_MIN, squelch)
end

function bgclear()
	draw_img(0, 0, 0)
	draw_set_pen(foreground[contrast])
	draw_set_bg(background[light])
	draw_clear(lcd.x0, lcd.y0, lcd.w, lcd.h)
	if gps_available then
		local t = utc()
		local x = lcd.npx - (string.len(t)+1) * FONT[FONT_TIME]['0'].w
		lcd_text(x, 1, t, FONT_TIME)
	end
	marker_volume()
	marker_squelch()
end

function draw_da_open()
	if (da_open) then
		draw_img(1, 500, 98)
	end
end

function strchar(t, i)
	local c = string.sub(t, i, i)
	if c == '<' then
		c = 'left'
	elseif c == '>' then
		c = 'right'
	elseif c == '^' then
		c = 'up'
	elseif c == '~' then
		c = 'down'
	elseif c == '$' then
		c = 'cursor'
	end
	return c
end

function invert_letter(l)
	local t = {}
	t.w = l.w
	t.h = l.h
	t.d = l.d
	t.d = t.d:gsub('#', '*'):gsub(' ', '#'):gsub('*', ' ')
	return t
end

function pixel(x, y)
	if x < 0 or x >= lcd.npx then return end
	if y < 0 or y >= lcd.npy then return end
	local x0 = lcd.x0 + x * lcd.pw
	local y0 = lcd.y0 + y * lcd.ph
	local x1 = x0 + lcd.pw
	local y1 = y0 + lcd.ph
	draw_rect(x0, y0, x1, y1)
end

function draw_letter(sx, sy, letter)
	for x = 1,letter.w,1 do
		for y = 1,letter.h,1 do
			local index = (y-1) * letter.w + x
			if string.sub(letter.d, index, index) == '#' then
				pixel(1+sx+x, sy+y)
			end
		end
	end
end

function lcd_text(x, y, t, f, attr)
	if not t then return end
	attr = attr or FONT_ATTR_NORMAL -- default value
	draw_set_pen(foreground[contrast])
	for i = 1,string.len(t),1 do
		local c = strchar(t, i)
		local letter = FONT[f][c]
		if not letter then
			error('unknown character  ' .. c .. '  for font ' .. f)
		end
		local id = f .. '-' .. c
		local lx = (i-1) * (letter.w) + x
		local ly = y
		if attr == FONT_ATTR_INVERSE then
			id = 'I-' .. id
		else
			id = 'N-' .. id
		end
		draw_bitmap(id, lcd.x0 + (lx+1) * lcd.pw, lcd.y0 + ly * lcd.ph, lcd.pw, lcd.ph)
	end
end

function menu(y, t)
	if not t then return end
	local x = (16 - string.len(t)) * FONT[FONT_MENU]['0'].w
	lcd_text(x, y, t, FONT_MENU)
end

function info(y, t)
	if not t then return end
	lcd_text(2*FONT[FONT_BIG]['0'].w, y, t, FONT_MENU)
end

function text(y, t, attr)
	if not t then return end
	lcd_text(0, y, t, FONT_MENU, attr)
end

function draw_position(lat, lon)
	text(MENU_0, lat)
	text(MENU_1, lon)
end

function draw_time(t)
	if string.len(t) <= 5 then
		text(MENU_2, t .. ' UTC')
	else
		text(MENU_2, t .. 'UTC')
	end
end

function chn_nz(c, f)
	lcd_text(0, lcd.npy-FONT[f]['0'].h, string.format('%2d', c), f)
end

function chn(c, f)
	lcd_text(0, lcd.npy-FONT[f]['0'].h, string.format('%02d', c), f)
end

function valid_channel(ch)
	return contains(CHANNELS, ch)
end

function valid_intership(ch)
	return contains(CHANNEL_INTERSHIP, ch)
end

function match(str, pat)
	local p0, p1 = string.find(str, pat)
	return p0 == 1 and p1 == string.len(str)
end

function valid_mmsi(mmsi)
	if not mmsi then return false end
	return string.len(mmsi) == 9 and match(mmsi, '[0-9]*')
end

function valid_ship_mmsi(mmsi)
	if not mmsi then return false end
	return string.len(mmsi) == 9 and match(mmsi, '[^0][^0][0-9]*')
end

function valid_group_mmsi(mmsi)
	if not mmsi then return false end
	return string.len(mmsi) == 9 and match(mmsi, '0[^0][0-9]*')
end

function valid_coast_mmsi(mmsi)
	if not mmsi then return false end
	return string.len(mmsi) == 9 and match(mmsi, '00[0-9]*')
end

function valid_position(lat, lon)
	if lat.m > 0 and lat.d >=  90 then return false end
	if lon.m > 0 and lon.d >= 180 then return false end
	return true
		and (lat.h == 1 or  lat.h ==  -1)
		and (lat.d >= 0 and lat.d <=  90)
		and (lat.m >= 0 and lat.m <=  59)
		and (lon.h == 1 or  lon.h ==  -1)
		and (lon.d >= 0 and lon.d <= 180)
		and (lon.m >= 0 and lon.m <=  59)
end

function is_turned_on()
	return volume > VOLUME_OFF
end

function is_turned_off()
	return volume == VOLUME_OFF
end

function is_num(id)
	return id and id >= 0x00 and id <= 0x09
end

function dir_name_already_registered(name)
	for i,e in pairs(directory) do
		if name == e.name then return true end
	end
	return false
end
--}}}

-- SUPPORTING CLASSES

enter_time = {} --{{{

function enter_time:open(menu_back)
	self.utc_init = '$-:--'
	self.utc = self.utc_init  -- pos: 0..3
	self.pos = 0
	self.menu_back = menu_back
end

function enter_time:close()
end

function enter_time:at_end()
	return self.pos == 4
end

function enter_time:at_start()
	return self.pos == 0
end

function enter_time:hour()
	if self:at_end() then
		return tonumber(self.utc:sub(0, 2))
	end
	return -1
end

function enter_time:minute()
	if self:at_end() then
		return tonumber(self.utc:sub(4, 5))
	end
	return -1
end

function enter_time:valid()
	if self:at_end() then
		local h = self:hour()
		local m = self:minute()
		return h >= 0 and h <= 23 and m >= 0 and m <= 59
	end
	return false
end

function enter_time:get_time()
	return 0.0 + self:hour() + (0.0 + self:minute()) / 60.0, self:hour(), self:minute()
end

function enter_time:put(char)
	if (self.pos >= 4) then return end
	if self.pos == 0 then
		self.utc = self.utc:sub(0, self.pos) .. char .. '$:--'
	elseif self.pos == 1 then
		self.utc = self.utc:sub(0, self.pos) .. char .. ':$-'
	elseif self.pos == 2 then
		self.utc = self.utc:sub(0, self.pos+1) .. char .. '$'
	elseif self.pos == 3 then
		self.utc = self.utc:sub(0, self.pos+1) .. char .. '$'
	end
	self.pos = self.pos + 1
end

function enter_time:del()
	if (self.pos <= 0) then return end
	self.pos = self.pos - 1
	if self.pos == 0 then
		self.utc = self.utc_init
	elseif self.pos == 1 then
		self.utc = self.utc:sub(0, 1) .. '$:--'
	elseif self.pos == 2 then
		self.utc = self.utc:sub(0, 3) .. '$-'
	elseif self.pos == 3 then
		self.utc = self.utc:sub(0, 4) .. '$'
	end
end

function enter_time:back()
	self:del()
end

function enter_time:handle(event)
	if event >= 0x00 and event <= 0x09 then
		self:put(event)
	end
	return nil
end

function enter_time:draw()
	draw_time(self.utc)
	if self.pos > 0 then
		menu(self.menu_back, '<')
	end
end
--}}}

enter_pos = {} --{{{

function enter_pos:open(menu_back)
	self.lat = '$-&--+' -- pos: 0..4
	self.lon = '---&--+' -- pos: 5..10
	self.pos = 0
	self.menu_back = menu_back
end

function enter_pos:close()
end

function enter_pos:at_start()
	return self.pos == 0
end

function enter_pos:at_end()
	return self.pos == 11
end

function enter_pos:get_lat_lon()
	local la = {
		h = 1,
		d = 0,
		m = 0,
	}
	local lo = {
		h = 1,
		d = 0,
		m = 0,
	}
	la.d = 0 + self.lat:sub(0, 2)
	la.m = 0 + self.lat:sub(4, 5)
	lo.d = 0 + self.lon:sub(0, 3)
	lo.m = 0 + self.lon:sub(5, 6)
	if self.lat:sub(6, 6) == 'S' then la.h = -1 end
	if self.lon:sub(7, 7) == 'E' then lo.h = -1 end
	return la, lo
end

function enter_pos:put(char)
	if self.pos >= 11 then return end
	if self.pos == 0 then
		-- latitude degrees
		self.lat = self.lat:sub(0, self.pos) .. char .. '$&--+'
	elseif self.pos == 1 then
		-- latitude degrees
		self.lat = self.lat:sub(0, self.pos) .. char .. '&$-+'
	elseif self.pos == 2 then
		-- latitude minutes
		self.lat = self.lat:sub(0, self.pos+1) .. char .. '$+'
	elseif self.pos == 3 then
		-- latitude minutes
		self.lat = self.lat:sub(0, self.pos+1) .. char .. '$'
	elseif (self.pos == 4) and ((char == 'N') or (char == 'S')) then
		-- latitude hemisphere
		self.lat = self.lat:sub(0, 5) .. char .. self.lat:sub(8)
		self.lon = '$--&--+'
	elseif self.pos == 5 then
		-- longitude degrees
		self.lon = self.lon:sub(0, self.pos-5) .. char .. '$-&--+'
	elseif self.pos == 6 then
		-- longitude degrees
		self.lon = self.lon:sub(0, self.pos-5) .. char .. '$&--+'
	elseif self.pos == 7 then
		-- longitude degrees
		self.lon = self.lon:sub(0, self.pos-5) .. char .. '&$-+'
	elseif self.pos == 8 then
		-- longitude minutes
		self.lon = self.lon:sub(0, self.pos-4) .. char .. '$+'
	elseif self.pos == 9 then
		-- longitude minutes
		self.lon = self.lon:sub(0, self.pos-4) .. char .. '$'
	elseif (self.pos == 10) and ((char == 'W') or (char == 'E')) then
		-- longitude hemisphere
		self.lon = self.lon:sub(0, 6) .. char .. self.lon:sub(8)
	end
	self.pos = self.pos + 1
end

function enter_pos:del()
	if (self.pos <= 0) then return end
	self.pos = self.pos - 1
	if self.pos == 0 then
		-- latitude degrees
		self.lat = self.lat:sub(0, self.pos) .. '$-&--+'
	elseif self.pos == 1 then
		-- latitude degrees
		self.lat = self.lat:sub(0, self.pos) .. '$&--+'
	elseif self.pos == 2 then
		-- latitude minutes
		self.lat = self.lat:sub(0, self.pos+1) .. '$-+'
	elseif self.pos == 3 then
		-- latitude minutes
		self.lat = self.lat:sub(0, self.pos+1) .. '$+'
	elseif (self.pos == 4) then
		-- latitude hemisphere
		self.lat = self.lat:sub(0, 5) .. '$'
		self.lon = '---&--+'
	elseif self.pos == 5 then
		-- longitude degrees
		self.lon = self.lon:sub(0, self.pos-5) .. '$--&--+'
	elseif self.pos == 6 then
		-- longitude degrees
		self.lon = self.lon:sub(0, self.pos-5) .. '$-&--+'
	elseif self.pos == 7 then
		-- longitude degrees
		self.lon = self.lon:sub(0, self.pos-5) .. '$&--+'
	elseif self.pos == 8 then
		-- longitude minutes
		self.lon = self.lon:sub(0, self.pos-4) .. '$-+'
	elseif self.pos == 9 then
		-- longitude minutes
		self.lon = self.lon:sub(0, self.pos-4) .. '$+'
	elseif self.pos == 10 then
		-- longitude hemisphere
		self.lon = self.lon:sub(0, 6) .. '$'
	end
end

function enter_pos:back()
	self:del()
end

function enter_pos:handle(event)
	if event == EVENT_SOFT_2 then
		if self.pos == 4 then
			self:put('N')
		elseif self.pos == 10 then
			self:put('W')
		end
	elseif event == EVENT_SOFT_3 then
		if self.pos == 4 then
			self:put('S')
		elseif self.pos == 10 then
			self:put('E')
		end
	elseif event >= 0x00 and event <= 0x09 then
		if self.pos ~= 4 and self.pos ~= 10 then
			self:put(event)
		end
	end
	return nil
end

function enter_pos:draw()
	draw_position(self.lat, self.lon)
	if self.pos > 0 then
		menu(self.menu_back, '<')
		if self.pos == 4 then
			menu(MENU_2, 'N')
			menu(MENU_3, 'S')
		end
		if self.pos == 10 then
			menu(MENU_2, 'W')
			menu(MENU_3, 'E')
		end
	end
end

--}}}

enter_mmsi = {} --{{{

function enter_mmsi:open(y, empty_char, prefix)
	self.max_length = 9
	self.y = y
	self.prefix = prefix
	self.char = empty_char
	self.mmsi = self.prefix .. '$' .. string.rep(self.char, self.max_length-string.len(self.prefix)-1)
	self.pos = string.len(self.prefix)
end

function enter_mmsi:close()
end

function enter_mmsi:at_start()
	return self.pos == string.len(self.prefix)
end

function enter_mmsi:at_end()
	return self.pos == self.max_length
end

function enter_mmsi:back()
	self:del()
end

function enter_mmsi:get_mmsi()
	return self.mmsi:sub(1, self.max_length)
end

function enter_mmsi:add(num)
	if self.pos >= self.max_length then return end
	if string.len(self.prefix) == 0 then
		self.mmsi = self.mmsi:sub(1, self.pos) .. num .. '$' .. string.rep(self.char, self.max_length-string.len(self.prefix)-self.pos-2)
	else
		self.mmsi = self.mmsi:sub(1, self.pos) .. num .. '$' .. string.rep(self.char, self.max_length-string.len(self.prefix)-self.pos-1)
	end
	self.pos = self.pos + 1
end

function enter_mmsi:del()
	if self.pos <= string.len(self.prefix) then return end
	self.pos = self.pos - 1
	self.mmsi = self.mmsi:sub(1, self.pos) .. '$' .. string.rep(self.char, self.max_length-self.pos-1)
end

function enter_mmsi:handle(event)
	if event >= 0x00 and event <= 0x09 then
		self:add(event)
	end
	return nil
end

function enter_mmsi:draw()
	text(self.y, self.mmsi)
end

--}}}

enter_name = {} --{{{

function enter_name:open(y, empty_char, prefix)
	self.max_length = 10
	self.y = y
	self.prefix = prefix
	self.char = empty_char
	self.v = self.prefix .. string.rep(self.char, self.max_length-string.len(self.prefix))
	self.pos = string.len(self.prefix)
	self.last = nil
	self.last_cnt = 1
	self.pressed = false
end

function enter_name:close()
	timer_stop(EVENT_TIMER_NEXT)
end

function enter_name:back()
	timer_stop(EVENT_TIMER_NEXT)
	self:del()
end

function enter_name:calc_case(c, pos)
	if pos <= string.len(self.prefix) then
		return string.upper(c)
	else
		local pc = self.v:sub(pos, pos)
		if pc ~= ' ' then
			return string.lower(c)
		else
			return string.upper(c)
		end
	end
end

function enter_name:replace(c)
	local cx = self:calc_case(c, self.pos-1)
	self.v = self.v:sub(1, self.pos-1) .. cx .. self.v:sub(self.pos+1)
end

function enter_name:add(c)
	if self.pos >= self.max_length then return end
	local cx = self:calc_case(c, self.pos)
	if string.len(self.prefix) == 0 then
		self.v = self.v:sub(1, self.pos) .. cx .. string.rep(self.char, self.max_length-self.pos-1)
	else
		self.v = self.v:sub(1, self.pos) .. cx .. string.rep(self.char, self.max_length-string.len(self.prefix)-self.pos)
	end
	self.pos = self.pos + 1
end

function enter_name:del()
	if self.pos > string.len(self.prefix) then
		self.pos = self.pos - 1
		self.v = self.v:sub(1, self.pos) .. string.rep(self.char, self.max_length-self.pos)
		self.last = nil
	end
end

function enter_name:get_name()
	return self.v:sub(1, self.pos)
end

function enter_name:at_start()
	return self.pos == string.len(self.prefix)
end

function enter_name:at_end()
	return self.pos == self.max_length
end

function enter_name:get_pos()
	return self.pos
end

function enter_name:handle(event)
	if is_num(event) and self.pos < self.max_length then
		if event == self.last then
			self.last_cnt = self.last_cnt + 1
			if self.last_cnt > #(ENTER_TABLE[self.last]) then self.last_cnt = 1 end
			self:replace(ENTER_TABLE[self.last][self.last_cnt])
			timer_start(EVENT_TIMER_NEXT, NAME_KEY_TIMEOUT)
		else -- not the same button
			self.last_cnt = 1
			self.last = event
			self:add(ENTER_TABLE[event][1])
			timer_start(EVENT_TIMER_NEXT, NAME_KEY_TIMEOUT)
		end
	elseif is_num(event) and self.pos >= self.max_length then
		self.last_cnt = 1
		self.last = nil
		view_update()
	elseif event == EVENT_TIMER_NEXT then
		self.last_cnt = 1
		self.last = nil
		view_update()
	end
	return nil
end

function enter_name:draw()
	local w = FONT[FONT_MENU]['0'].w

	if self.pos == 0 and self.last == nil then
		lcd_text(0, self.y, '$' .. self.v:sub(2), FONT_MENU, FONT_ATTR_NORMAL)
	elseif self.pos > 0 and self.last ~= nil then
		lcd_text(0, self.y, self.v:sub(1, self.pos-1), FONT_MENU, FONT_ATTR_NORMAL)
		lcd_text(w*(self.pos-1), self.y, self.v:sub(self.pos, self.pos), FONT_MENU, FONT_ATTR_INVERSE)
		lcd_text(w*self.pos, self.y, self.v:sub(self.pos+1), FONT_MENU, FONT_ATTR_NORMAL)
	else
		lcd_text(0, self.y, self.v:sub(1, self.pos), FONT_MENU, FONT_ATTR_NORMAL)
		lcd_text(w*self.pos, self.y, '$', FONT_MENU, FONT_ATTR_NORMAL)
		lcd_text(w*(self.pos+1), self.y, self.v:sub(self.pos+2), FONT_MENU, FONT_ATTR_NORMAL)
	end
end
--}}}

-- STATES

state_off = {} --{{{

-- Handles the off state of the VHF. The device has
-- to be turned on using the volume knob.

function state_off:open()
	channel = CHANNEL_EMERGENCY
	new_channel = -1
	volume = VOLUME_OFF
	light = LIGHT_OFF
	contrast = CONTRAST_MAX - 1
	power = POWER_HI
	da_open = false
	handle_volume()
	handle_squelch()
	gen_vhf_clear_pos_time()
end

function state_off:close()
end

function state_off:handle(event)
	if event == EVENT_VOLUME_UP then
		volume = VOLUME_MIN
		handle_volume()
		return state_rad
	end
	return nil
end

function state_off:draw()
	bgclear()
end
--}}}

state_rad = {} --{{{

-- Represents the RAD mode of the VHF. Virtually no features
-- are supported, only choosing a new channel and changing to
-- the DSC mode.
-- In this state, the timer EVENT_TIMER is used to handle the
-- timeout while choosing a channel. If the enter button is
-- not pressed within the timeout, the new channel is discarded.

function state_rad:open()
	if channel == CHANNEL_EMERGENCY then
		power = POWER_HI
	end
	if (channel == 15) or (channel == 17) then
		power = POWER_LO
	end
	self.start_with_zero = false
	self.num = 0
	self.entering = false
end

function state_rad:close()
	timer_stop(EVENT_TIMER)
end

function state_rad:handle(event)
	if event == EVENT_TOGGLEPOWER then
		toggle_power()
	elseif is_num(event) then
		self.entering = true
		if self.num <= 0 then
			if event == 0 then
				self.start_with_zero = true
			end
		end
		self.num = self.num + 1
		if new_channel < 0 then
			new_channel = event
		elseif new_channel >= 0 and new_channel < 10 then
			new_channel = new_channel * 10 + event
		end
		timer_start(EVENT_TIMER, CHANNEL_KEY_TIMEOUT)
	elseif event == EVENT_CANCEL then
		timer_stop(EVENT_TIMER)
		new_channel = -1
		self.start_with_zero = false
		self.num = 0
		self.entering = false
	elseif event == EVENT_ENTER then
		timer_stop(EVENT_TIMER)
		self.entering = false
		if new_channel >= 0 then
			if valid_channel(new_channel) then
				channel = new_channel
				new_channel = -1
				self.start_with_zero = false
				self.num = 0
				-- handling of the output power according to the
				-- choosen channel
				if (channel == CHANNEL_EMERGENCY) then
					power = POWER_HI
				end
				if contains(CHANNEL_LO_POWER, channel) then
					power = POWER_LO
				end
			else
				snd_play(SND_BEEP_ERROR, 0)
				new_channel = -1
				self.start_with_zero = false
				self.num = 0
			end
		end
	elseif event == EVENT_TIMER then
		new_channel = -1
		self.start_with_zero = false
		self.num = 0
		self.entering = false
		view_update()
	elseif event == EVENT_SOFT_0 and not self.entering then
		return state_dsc_0
	elseif event == EVENT_DUALWATCH and channel ~= CHANNEL_EMERGENCY then
		self.entering = false
		if new_channel >= 0 then
			new_channel = -1
			self.start_with_zero = false
			self.num = 0
		else
			dw_channel = channel
			channel = CHANNEL_EMERGENCY
			return state_dual_watch
		end
	end
	return nil
end

function state_rad:draw()
	bgclear()
	if not self.entering then
		menu(MENU_0, 'DSC')
		menu(MENU_1, 'T/W')
		menu(MENU_2, 'M/S')
		menu(MENU_3, 'Scan')
	end
	info(MENU_0, 'INT')
	info(MENU_1, POWER_TEXT[power])
	if light > LIGHT_OFF then
		info(MENU_2, 'Lite')
	end
	info(MENU_3, 'Rx')
	if new_channel >= 0 then
		if self.start_with_zero and self.num > 1 then
			chn(new_channel, FONT_BIG)
		else
			chn_nz(new_channel, FONT_BIG)
		end
	else
		chn(channel, FONT_BIG)
	end
end
--}}}

state_dsc_0 = {} --{{{

-- This is the first DSC menu. It just provides access to
-- subsequent menues without any further logic.

function state_dsc_0:open()
end

function state_dsc_0:close()
	timer_stop(EVENT_TIMER)
end

function state_dsc_0:handle(event)
	if event == EVENT_SOFT_0 then
		return state_rad
	elseif event == EVENT_SOFT_1 then
		if not (mmsi_get_ship() == '000000000') then
			return state_dsc_call
		end
	elseif event == EVENT_SOFT_2 then
		if #call_log > 0 then
			return state_call_log
		end
	elseif event == EVENT_SOFT_3 then
		return state_dsc_1
	elseif event == EVENT_CANCEL then
		return state_rad
	end
	return nil
end

function state_dsc_0:draw()
	bgclear()
	if new_channel >= 0 then
		chn(new_channel, FONT_SMALL)
	else
		chn(channel, FONT_SMALL)
	end
	if have_pos() then
		draw_position(latitude(), longitude())
	else
		text(MENU_0, 'No position')
		text(MENU_1, ' available ')
	end
	menu(MENU_0, 'Rad')
	if not (mmsi_get_ship() == '000000000') then
		menu(MENU_1, 'Call')
	end
	menu(MENU_2, 'Log')
	menu(MENU_3, 'Menu')
	info(MENU_3, 'Rx')
end
--}}}

state_dsc_1 = {} --{{{

-- This is another DSC menu. It just provides access to
-- subsequent menues without any further logic.

function state_dsc_1:open()
end

function state_dsc_1:close()
end

function state_dsc_1:handle(event)
	if event == EVENT_TOGGLEPOWER then
		toggle_power()
	elseif event == EVENT_SOFT_0 then
		return state_dsc_0
	elseif event == EVENT_SOFT_1 then
		return state_lcd_contrast
	elseif event == EVENT_SOFT_2 then
		return state_dsc_pos
	elseif event == EVENT_SOFT_3 then
		return state_dsc_2
	elseif event == EVENT_CANCEL then
		return state_dsc_0
	end
	return nil
end

function state_dsc_1:draw()
	bgclear()
	chn(channel, FONT_SMALL)
	if have_pos() then
		draw_position(latitude(), longitude())
	else
		text(MENU_0, 'No position')
		text(MENU_1, ' available ')
	end
	menu(MENU_0, 'DSC')
	menu(MENU_1, 'LCD')
	menu(MENU_2, 'Posn')
	menu(MENU_3, 'More')
	info(MENU_3, 'Rx')
end
--}}}

state_dsc_2 = {} --{{{

-- This is another DSC menu. It just provides access to
-- subsequent menues without any further logic.

function state_dsc_2:open()
end

function state_dsc_2:close()
end

function state_dsc_2:handle(event)
	if (event == EVENT_TOGGLEPOWER) then
		toggle_power()
	elseif (event == EVENT_SOFT_0) then
		return state_dsc_0
	elseif (event == EVENT_SOFT_1) then
		return state_menu_mmsi
	elseif (event == EVENT_SOFT_2) then
		return state_directory
	elseif (event == EVENT_SOFT_3) then
		return state_dsc_3
	elseif (event == EVENT_CANCEL) then
		return state_dsc_1
	end
	return nil
end

function state_dsc_2:draw()
	bgclear()
	chn(channel, FONT_SMALL)
	if have_pos() then
		draw_position(latitude(), longitude())
	else
		text(MENU_0, 'No position')
		text(MENU_1, ' available ')
	end
	menu(MENU_0, 'DSC')
	menu(MENU_1, 'MMSI')
	menu(MENU_2, 'Dir')
	menu(MENU_3, 'More')
	info(MENU_3, 'Rx')
end
--}}}

state_dsc_3 = {} --{{{

-- This is the last of the DSC menues and provides
-- access to the configuration of the key beep.

function state_dsc_3:open()
end

function state_dsc_3:close()
end

function state_dsc_3:handle(event)
	if event == EVENT_TOGGLEPOWER then
		toggle_power()
	elseif event == EVENT_SOFT_0 then
		return state_dsc_0
	elseif event == EVENT_SOFT_1 then
		if beep_enable then
			beep_enable = false
		else
			beep_enable = true
		end
	elseif event == EVENT_CANCEL then
		return state_dsc_2
	end
	return nil
end

function state_dsc_3:draw()
	bgclear()
	chn(channel, FONT_SMALL)
	if have_pos() then
		draw_position(latitude(), longitude())
	else
		text(MENU_0, 'No position')
		text(MENU_1, ' available ')
	end
	menu(MENU_0, 'DSC')
	menu(MENU_1, 'Beep')
	info(MENU_3, 'Rx')
end
--}}}

state_dual_watch = {} --{{{

-- A special case of the RAD mode, where besides 16 another
-- channel is being supervised.
-- The timer EVENT_TIMER is used to toggle between the two
-- channels. The timing is asymmetric.

function state_dual_watch:open()
	self.flag = 0
	channel = CHANNEL_EMERGENCY
	timer_start(EVENT_TIMER, 150)
end

function state_dual_watch:close()
	timer_stop(EVENT_TIMER)
end

function state_dual_watch:handle(event)
	if event == EVENT_TIMER then
		if self.flag == 0 then
			self.flag = 1
			timer_start(EVENT_TIMER, 1000)
		elseif self.flag == 1 then
			self.flag = 0
			timer_start(EVENT_TIMER, 150)
		end
		view_update()
	elseif event == EVENT_SOFT_0 then
		channel = dw_channel
		return state_dsc_0
	elseif event == EVENT_CANCEL then
		channel = dw_channel
		return state_rad
	elseif event == EVENT_DUALWATCH then
		channel = dw_channel
		return state_rad
	end
	return nil
end

function state_dual_watch:draw()
	bgclear()
	if self.flag == 0 then
		chn(channel, FONT_BIG)
		info(MENU_1, POWER_TEXT[POWER_HI])
	else
		chn(dw_channel, FONT_BIG)
		info(MENU_1, POWER_TEXT[power])
	end
	menu(MENU_0, 'DSC')
	info(MENU_0, 'INT')
	info(MENU_2, 'Ch16')
	info(MENU_3, 'D/W')
end
--}}}

state_dsc_pos = {} --{{{

-- This is another subsequent DSC menu and provides
-- access to other configuration menues regarding
-- position and time.

function state_dsc_pos:open()
end

function state_dsc_pos:close()
end

function state_dsc_pos:handle(event)
	if event == EVENT_TOGGLEPOWER then
		toggle_power()
	elseif event == EVENT_SOFT_0 then
		return state_dsc_0
	elseif event == EVENT_SOFT_1 then
		return state_enter_pos
	elseif event == EVENT_SOFT_2 then
		return state_enter_time
	elseif event == EVENT_CANCEL then
		return state_dsc_1
	end
	return nil
end

function state_dsc_pos:draw()
	bgclear()
	draw_time(utc())
	draw_position(latitude(), longitude())
	menu(MENU_0, 'DSC')
	menu(MENU_1, 'Posn')
	menu(MENU_2, 'UTC')
end
--}}}

state_enter_pos = {} --{{{

-- Using the structure 'enter_pos' this state asks for
-- a position to enter. It is also possible to toggle
-- to the time configuration.
-- Only valid positions are accepted, e.g. a longitude
-- of 99-99N is invalid as is a latitude of 234-00W.
-- The position is only valid if both latitude and
-- longitude are valid.

function state_enter_pos:open()
	self.enter = enter_pos
	self.enter:open(MENU_0)
end

function state_enter_pos:close()
	self.enter:close()
	self.enter = nil
end

function state_enter_pos:handle(event)
	if event == EVENT_TOGGLEPOWER then
		toggle_power()
	elseif event == EVENT_SOFT_0 then
		if self.enter:at_start() then
			return state_dsc_0
		else
			self.enter:back()
		end
	elseif event == EVENT_SOFT_2 then
		if self.enter:at_start() then
			return state_enter_time
		else
			self.enter:handle(event)
		end
	elseif event == EVENT_SOFT_3 then
		self.enter:handle(event)
	elseif is_num(event) then
		self.enter:handle(event)
	elseif event == EVENT_ENTER then
		if self.enter:at_end() then
			local la,lo = self.enter:get_lat_lon()
			if valid_position(la, lo) then
				pos_set_lat(la.h, la.d, la.m)
				pos_set_lon(lo.h, lo.d, lo.m)
				return state_enter_time
			else
				snd_play(SND_BEEP_ERROR, 0)
				self.enter:close()
				self.enter = enter_pos
				self.enter:open(MENU_0)
			end
		end
	elseif event == EVENT_CANCEL then
		return state_dsc_pos
	end
	return nil
end

function state_enter_pos:draw()
	bgclear()
	self.enter:draw()
	draw_time(utc())
	if self.enter:at_start() then
		menu(MENU_0, 'DSC')
		menu(MENU_2, 'UTC')
	end
end
--}}}

state_enter_time = {} --{{{

-- This state asks for a time in UTC. It is also possible
-- to toggle to the position configuration.
-- Only valid times are accepted, e.g. 22:66 is invalid.
-- To enter the time 'enter_time' is utilized.

function state_enter_time:open()
	self.enter = enter_time
	self.enter:open(MENU_0)
end

function state_enter_time:close()
	self.enter:close()
	self.enter = nil
end

function state_enter_time:handle(event)
	if event == EVENT_TOGGLEPOWER then
		toggle_power()
	elseif event == EVENT_SOFT_0 then
		if self.enter:at_start() then
			return state_dsc_0
		else
			self.enter:back()
		end
	elseif event == EVENT_SOFT_2 then
		return state_enter_pos
	elseif is_num(event) then
		self.enter:handle(event)
	elseif event == EVENT_ENTER then
		if self.enter:at_end() then
			if self.enter:valid() then
				local t,h,m = self.enter:get_time()
				time_set(t)
				return state_dsc_pos
			else
				self.enter:close()
				self.enter = enter_time
				self.enter:open(MENU_0)
				snd_play(SND_BEEP_ERROR, 0)
			end
		end
	elseif event == EVENT_CANCEL then
		return state_dsc_pos
	end
	return nil
end

function state_enter_time:draw()
	bgclear()
	draw_position(latitude(), longitude())
	self.enter:draw()
	if self.enter:at_start() then
		menu(MENU_0, 'DSC')
		menu(MENU_2, 'Posn')
	end
end
--}}}

state_menu_mmsi = {} --{{{

function state_menu_mmsi:open()
	self.mmsi_not_defined = (mmsi_get_ship() == '000000000')
end

function state_menu_mmsi:close()
end

function state_menu_mmsi:handle(event)
	if event == EVENT_TOGGLEPOWER then
		toggle_power()
	elseif event == EVENT_SOFT_0 then
		return state_dsc_0
	elseif event == EVENT_SOFT_1 and self.mmsi_not_defined then
		return state_enter_mmsi
	elseif event == EVENT_SOFT_3 then
		return state_enter_group_mmsi
	elseif event == EVENT_CANCEL then
		return state_dsc_2
	end
	return nil
end

function state_menu_mmsi:draw()
	self.mmsi_not_defined = (mmsi_get_ship() == '000000000')
	bgclear()
	menu(MENU_0, 'DSC')
	menu(MENU_3, '>')
	if self.mmsi_not_defined then
		menu(MENU_1, '>')
	end

	-- ship MMSI
	text(MENU_0, 'Ship MMSI')
	tmp = mmsi_get_ship()
	if (tmp == '000000000') then
		text(MENU_1, string.rep('-', 9))
	else
		text(MENU_1, tmp)
	end

	-- group MMSI
	text(MENU_2, 'Group MMSI')
	text(MENU_3, mmsi_get_group())
end
--}}}

state_enter_mmsi = {} --{{{

function state_enter_mmsi:open()
	self.enter = enter_mmsi
	self.enter:open(MENU_1, '-', '')
end

function state_enter_mmsi:close()
	self.enter:close()
	self.enter = nil
end

function state_enter_mmsi:handle(event)
	if event == EVENT_TOGGLEPOWER then
		toggle_power()
	elseif event == EVENT_SOFT_0 then
		return state_dsc_0
	elseif event == EVENT_SOFT_1 then
		self.enter:back()
	elseif is_num(event) then
		self.enter:handle(event)
	elseif event == EVENT_CANCEL then
		return state_menu_mmsi
	elseif event == EVENT_ENTER then
		local mmsi = self.enter:get_mmsi()
		if valid_ship_mmsi(mmsi) then
			mmsi_set_ship(self.enter:get_mmsi())
			return state_dsc_0
		else
			snd_play(SND_BEEP_ERROR, 0)
		end
	end
	return nil
end

function state_enter_mmsi:draw()
	bgclear()
	menu(MENU_0, 'DSC')
	menu(MENU_1, '<')
	text(MENU_0, 'Ship MMSI')
	self.enter:draw()
end
--}}}

state_enter_group_mmsi = {} --{{{

function state_enter_group_mmsi:open()
	self.enter = enter_mmsi
	self.enter:open(MENU_1, '-', '0')
end

function state_enter_group_mmsi:close()
	self.enter:close()
	self.enter = nil
end

function state_enter_group_mmsi:handle(event)
	if event == EVENT_TOGGLEPOWER then
		toggle_power()
	elseif event == EVENT_SOFT_0 then
		return state_dsc_0
	elseif event == EVENT_SOFT_1 then
		self.enter:back()
	elseif is_num(event) then
		self.enter:handle(event)
	elseif event == EVENT_CANCEL then
		return state_menu_mmsi
	elseif event == EVENT_ENTER then
		local mmsi = self.enter:get_mmsi()
		if valid_group_mmsi(mmsi) then
			mmsi_set_group(mmsi)
			return state_menu_mmsi
		else
			snd_play(SND_BEEP_ERROR, 0)
		end
	end
	return nil
end

function state_enter_group_mmsi:draw()
	bgclear()
	menu(MENU_0, 'DSC')
	menu(MENU_1, '<')
	text(MENU_0, 'Group MMSI')
	self.enter:draw()
end
--}}}

state_send_distress = {} --{{{

-- This state is a hierarchical state machine with no history,
-- because it only can be opened using the distress alert button.
-- If no position and/or time is available (entered manually or
-- a GPS is present), those information can be entered during
-- this state.

function state_send_distress:open()
	-- substates handled by this state
	STATE_NORMAL   = 0
	STATE_COUNTING = 1
	STATE_SENDING  = 2
	STATE_WAIT_ACK = 3
	STATE_TIME     = 4
	STATE_POS      = 5

	-- initialization of the sub state machine
	self.state = STATE_NORMAL
	self.cnt = 0
	self.des = 0
	self.enter = nil

	-- this state is temporarily taking over the control over the
	-- distress events
	handling_distress = true
end

function state_send_distress:close()
	da_open = false
	wait_for_ack = false
	handling_distress = false -- releases the control over the distress events
	if self.enter then
		self.enter:close()
		self.enter = nil
	end
end

function state_send_distress:handle(event)
	-- main menu to send distress alerts
	if self.state == STATE_NORMAL then
		if event == EVENT_CANCEL then
			return state_rad
		elseif event == EVENT_SOFT_1 and not gps_available then
			self.enter = enter_pos
			self.enter:open(MENU_1)
			self.state = STATE_POS
		elseif event == EVENT_SOFT_2 and not gps_available then
			self.enter = enter_time
			self.enter:open(MENU_1)
			self.state = STATE_TIME
		elseif event == EVENT_SOFT_3 then
			self.des = (self.des + 1) % 11
		elseif event == EVENT_DISTRESS_CLOSE_RELEASE then
			-- distress alert was open and now closing
			da_open = false
			view_update()
		elseif event == EVENT_DISTRESS_RELEASE and not da_open then
			da_open = true
			view_update()
		elseif event == EVENT_DISTRESS_PRESS and da_open then
			self.cnt = 5
			timer_start(EVENT_TIMER, 1000)
			snd_play(SND_BEEP1, 0)
			self.state = STATE_COUNTING
		end
	-- enter time
	elseif self.state == STATE_TIME then
		if event == EVENT_SOFT_0 then
			self.state = STATE_NORMAL
			self.enter:close()
			self.enter = nil
		elseif event == EVENT_SOFT_1 then
			if not self.enter:at_start() then
				self.enter:back()
			end
		elseif event == EVENT_SOFT_2 then
			if self.enter:at_start() then
				self.enter:close()
				self.enter = enter_pos
				self.enter:open(MENU_1)
				self.state = STATE_POS
			end
		elseif is_num(event) then
			self.enter:handle(event)
		elseif event == EVENT_ENTER then
			if self.enter:at_end() then
				if self.enter:valid() then
					local t,h,m = self.enter:get_time()
					time_set(t)
					self.state = STATE_NORMAL
					self.enter:close()
					self.enter = nil
				else
					snd_play(SND_BEEP_ERROR, 0)
					self.enter:close()
					self.enter = enter_time
					self.enter:open(MENU_1)
				end
			end
		elseif event == EVENT_CANCEL then
			self.state = STATE_NORMAL
			self.enter:close()
			self.enter = nil
		end
	-- enter position
	elseif self.state == STATE_POS then
		if event == EVENT_SOFT_0 then
			self.state = STATE_NORMAL
			self.enter:close()
			self.enter = nil
		elseif event == EVENT_SOFT_1 then
			if not self.enter:at_start() then
				self.enter:back()
			end
		elseif event == EVENT_SOFT_2 then
			if self.enter:at_start() then
				self.enter:close()
				self.enter = enter_time
				self.enter:open(MENU_1)
				self.state = STATE_TIME
			else
				self.enter:handle(event)
			end
		elseif event == EVENT_SOFT_3 then
			self.enter:handle(event)
		elseif is_num(event) then
			self.enter:handle(event)
		elseif event == EVENT_ENTER then
			if self.enter:at_end() then
				local la,lo = self.enter:get_lat_lon()
				if valid_position(la, lo) then
					pos_set_lat(la.h, la.d, la.m)
					pos_set_lon(lo.h, lo.d, lo.m)
					self.enter:close()
					self.enter = enter_time
					self.enter:open(MENU_1)
					self.state = STATE_TIME
				else
					snd_play(SND_BEEP_ERROR, 0)
					self.enter:close()
					self.enter = enter_pos
					self.enter:open(MENU_1)
				end
			end
		elseif event == EVENT_CANCEL then
			self.state = STATE_NORMAL
			self.enter:close()
			self.enter = nil
		end
	-- sub state while pressing the distress alert button
	-- to send the distress alert
	elseif self.state == STATE_COUNTING then
		timer_start(EVENT_TIMER, 1000)
		if event == EVENT_TIMER and self.cnt > 1 then
			snd_play(SND_BEEP1, 0)
			self.cnt = self.cnt - 1
			view_update()
		elseif event == EVENT_TIMER and self.cnt <= 1 then
			timer_stop(EVENT_TIMER)
			snd_stop(SND_BEEP1)
			da_open = false
			wait_for_ack = true
			msg_send(mmsi_get_ship(), CHANNEL_EMERGENCY, POWER_WATT[POWER_HI], DSC_ALERT, DSC_ALL, self.des)
			self.state = STATE_SENDING
			timer_start(EVENT_TIMER, 1000)
			view_update()
		elseif event == EVENT_DISTRESS_RELEASE and da_open and self.cnt > 0 then
			timer_stop(EVENT_TIMER)
			snd_stop(SND_BEEP1)
			self.state = STATE_NORMAL
			view_update()
		end
	-- state while sending (simulated) the distress alert, this
	-- state will happen after a configured time holding down the
	-- distress alert button. this is the successor state of STATE_COUNTING.
	elseif self.state == STATE_SENDING then
		if event == EVENT_DISTRESS_RELEASE then
			-- ignore
		elseif event == EVENT_TIMER then
			snd_play(SND_DISTRESS, 0)
			self.state = STATE_WAIT_ACK
			if not in_exam_mode then
				-- a resend is only be done if not in exam mode.
				timer_start(EVENT_TIMER, DISTRESS_RESEND_TIME)
			end
			view_update()
		end
	-- waiting for an acknowledge (usually sent by a coast station)
	elseif self.state == STATE_WAIT_ACK then
		if event == EVENT_DISTRESS_PRESS then
			-- ignore
		elseif event == EVENT_DISTRESS_RELEASE and not da_open then
			da_open = true
			view_update()
		elseif event == EVENT_DISTRESS_RELEASE and da_open then
			wait_for_ack = false
			self.state = STATE_NORMAL
			view_update()
		elseif event == EVENT_TIMER then
			-- resend after defined time and no ACK but not in exam mode.
			-- in exam mode we just ignore this event, a resend will not happen
			if not in_exam_mode then
				wait_for_ack = true
				msg_send(mmsi_get_ship(), CHANNEL_EMERGENCY, POWER_WATT[POWER_HI], DSC_ALERT, DSC_ALL, self.des)
				snd_play(SND_DISTRESS, 0)
				self.state = STATE_SENDING
				timer_start(EVENT_TIMER, 1000)
				view_update()
			end
		elseif event == EVENT_CANCEL then
			wait_for_ack = false
			return state_rad
		elseif event == EVENT_MSG_RECV then
			local m = last_msg
			if m.dsc.type == DSC_ACK then
				set_emerg_ch()
				view_update()
				return state_rad
			end
		end
	end
	return nil
end

function state_send_distress:draw()
	bgclear()
	if self.state == STATE_NORMAL then
		text(MENU_0, 'Distress Alert')
		text(MENU_1, latitude() .. ' ' .. longitude())
		draw_time(utc())
		text(MENU_3, DISTRESS_DESIGNATION[self.des])
		if not gps_available then
			menu(MENU_1, '>')
			menu(MENU_2, '>')
		end
		menu(MENU_3, '>')
	elseif self.state == STATE_TIME then
		self.enter:draw()
		draw_position(latitude(), longitude())
		menu(MENU_0, 'DSC')
		text(MENU_3, DISTRESS_DESIGNATION[self.des])
		if self.enter:at_start() then
			menu(MENU_2, 'Posn')
		end
	elseif self.state == STATE_POS then
		self.enter:draw()
		draw_time(utc())
		menu(MENU_0, 'DSC')
		text(MENU_3, DISTRESS_DESIGNATION[self.des])
		if self.enter:at_start() then
			menu(MENU_2, 'UTC')
		end
	elseif self.state == STATE_COUNTING then
		text(MENU_0, ' DISTRESS ALERT ')
		text(MENU_2, '   Sending in   ')
		text(MENU_3, string.format('     %1d secs     ', self.cnt))
	elseif self.state == STATE_SENDING then
		text(MENU_0, '    SENDING     ')
		text(MENU_2, ' DISTRESS ALERT ')
	elseif self.state == STATE_WAIT_ACK then
		chn(channel, FONT_SMALL)
		text(MENU_0, 'DISTRESS SENT')
		text(MENU_1, 'AWAITING REPLY')
		info(MENU_3, 'Rx')
	end
end
--}}}

state_dsc_call = {} --{{{

-- This is the most complex state in the entire VHF simulation.
-- It provides the ability to send any type of DSC call, except
-- the distress alert. This state allows to send
--  - routine calls (chosen from directory)
--  - routine calls (MMSI entered manually)
--  - safety calls
--  - urgency calls
--  - group calls (chosen from directory)
--  - group calls (MMSI entered manually)
-- Channels are handled according to the chosen call type,
-- as well as the output power is.
-- For routine calls, only intership channels (simplex) are
-- possible.
-- This state is a superstate of its substates, a hierarchical
-- statemachine. The history is determined by the data package
-- specified while opening the state (see method 'open').

function state_dsc_call:open(data)
	-- The following initialization of this state is to
	-- set it up correctory, no matter from which subsequent
	-- state the data is sent.
	-- The main difference is to be made between routine calls
	-- with chosen destinations from the directory (TYPE_ROUTINE)
	-- and routine calls with a manually entered MMSI (TYPE_ROUTINE_IND).
	if #directory > 0 then
		self.type = TYPE_ROUTINE
	else
		self.type = TYPE_ROUTINE_IND
	end
	self.dir = 0
	self.mmsi = nil
	self.channel = CHANNEL_INTERSHIP[1]
	self.enter = nil
	if data then
		if data.name then
			for i = 1,#directory do
				if data.name == directory[i].name then
					self.dir = i-1
				end
			end
		else
			self.mmsi = data.mmsi
		end
		if data.type then
			self.type = data.type
		else
			if #directory > 0 then
				self.type = TYPE_ROUTINE
			else
				self.type = TYPE_ROUTINE_IND
			end
		end
		if data.channel then
			self.channel = data.channel
		end
	end
	if self.type == TYPE_ROUTINE_IND and not self.mmsi then
		self.enter = enter_mmsi
		self.enter:open(MENU_1, '-', '')
	end

	-- This table is sent as data package to other
	-- states that are working together with this state,
	-- 'state_dsc_call_channel' for example.
	-- It is also the table that is received back from
	-- those states. All invalid fields are nil.
	self.data = {
		type = nil,
		num = nil,
		name = nil,
		mmsi = nil,
		channel = nil,
	}
end

function state_dsc_call:close()
	return self.data
end

function state_dsc_call:handle(event)
	if self.type == TYPE_ROUTINE and is_num(event) then
		self.enter = enter_mmsi
		self.enter:open(MENU_1, '-', '')
		self.type = TYPE_ROUTINE_IND
		self.enter:add(event)
	elseif self.type == TYPE_SAFETY and is_num(event) then
		self.enter = enter_mmsi
		self.enter:open(MENU_1, '-', '')
		self.type = TYPE_ROUTINE_IND
		self.enter:add(event)
	elseif self.type == TYPE_URGENCY and is_num(event) then
		self.enter = enter_mmsi
		self.enter:open(MENU_1, '-', '')
		self.type = TYPE_ROUTINE_IND
		self.enter:add(event)
	elseif self.type == TYPE_GROUP and is_num(event) then
		self.enter = enter_mmsi
		self.enter:open(MENU_1, '-', '')
		self.type = TYPE_ROUTINE_IND
		self.enter:add(event)
	elseif self.type == TYPE_ROUTINE_IND and is_num(event) then
		if not self.enter then
			self.enter = enter_mmsi
			self.enter:open(MENU_1, '-', '')
		end
		self.enter:add(event)
	elseif self.type == TYPE_ROUTINE_IND and event == EVENT_ENTER then
		if self.enter then
			if self.enter:at_end() then
				local mmsi = self.enter:get_mmsi()
				if valid_mmsi(mmsi) then
					self.mmsi = mmsi
					self.enter:close()
					self.enter = nil
				else
					snd_play(SND_BEEP_ERROR, 0)
				end
			end
		end
	elseif event == EVENT_CANCEL then
		return state_dsc_0
	elseif event == EVENT_SOFT_0 then
		self.mmsi = nil
		if self.enter then
			self.enter:close()
			self.enter = nil
			self.type = TYPE_ROUTINE
		end
		if mmsi_get_group() == '000000000' then
			self.type = (self.type + 1) % 3
		else
			self.type = (self.type + 1) % 4
		end
		if self.type == TYPE_ROUTINE and #directory == 0 then
			self.type = TYPE_ROUTINE_IND
			self.enter = enter_mmsi
			self.enter:open(MENU_1, '-', '')
		end
		if self.type == TYPE_ROUTINE or self.type == TYPE_ROUTINE_IND or self.type == TYPE_GROUP then
			self.channel = CHANNEL_INTERSHIP[1]
		else
			self.channel = CHANNEL_EMERGENCY
		end
	elseif event == EVENT_SOFT_1 and self.enter ~= nil then
		self.enter:back()
	elseif event == EVENT_SOFT_1 and #directory > 0 then
		if self.mmsi then
			self.mmsi = nil
			self.dir = 0
		else
			self.dir = (self.dir + 1) % #directory
		end
	elseif event == EVENT_SOFT_2 and self.type ~= TYPE_URGENCY and not valid_coast_mmsi(self.mmsi) then
		if self.mmsi then
			self.data.mmsi = self.mmsi
		elseif #directory > 1 then
			self.data.name = directory[self.dir+1].name
			self.data.mmsi = directory[self.dir+1].mmsi
		else
			self.data.name = nil
			self.data.mmsi = nil
		end
		self.data.channel = self.channel
		self.data.type = self.type
		return state_dsc_call_channel
	elseif event == EVENT_SOFT_3 and not self.enter then
		if self.type == TYPE_ROUTINE and self.mmsi then
			self.data.mmsi = self.mmsi
		elseif self.type == TYPE_ROUTINE_IND and self.mmsi then
			self.data.mmsi = self.mmsi
		elseif self.type == TYPE_GROUP then
			self.data.mmsi = mmsi_get_group()
		else
			-- TODO:DISABLED:mk-2010-11-15
			--	self.data.name = directory[self.dir+1].name
			--	self.data.mmsi = directory[self.dir+1].mmsi
			self.data.mmsi = mmsi_get_ship()
		end
		if valid_coast_mmsi(self.data.mmsi) then
			self.data.channel = channel
		else
			self.data.channel = self.channel
		end
		self.data.type = self.type
		return state_dsc_call_send
	end
	return nil
end

function state_dsc_call:draw()
	bgclear()
	chn(channel, FONT_SMALL)
	info(MENU_3, 'Rx')
	if self.type == TYPE_ROUTINE then
		text(MENU_0, 'Routine to')
		if self.mmsi then
			text(MENU_1, self.mmsi)
		else
			if #directory > 0 then
				text(MENU_1, directory[self.dir+1].name)
			end
		end
		if #directory > 0 then
			menu(MENU_1, 'Dir')
		end
		menu(MENU_0, 'Type')
		menu(MENU_3, 'Send')
		if not valid_coast_mmsi(self.mmsi) then
			menu(MENU_2, string.format('Ch%02d', self.channel))
		end
	elseif self.type == TYPE_ROUTINE_IND then
		text(MENU_0, 'Routine to')
		if self.enter then
			self.enter:draw()
			if self.enter:at_start() then
				menu(MENU_0, 'Type')
				if not valid_coast_mmsi(self.mmsi) then
					menu(MENU_2, string.format('Ch%02d', self.channel))
				end
			elseif self.enter:at_end() then
				menu(MENU_1, '<')
			else
				menu(MENU_1, '<')
			end
		else
			text(MENU_1, self.mmsi)
			menu(MENU_0, 'Type')
			menu(MENU_3, 'Send')
			if not valid_coast_mmsi(self.mmsi) then
				menu(MENU_2, string.format('Ch%02d', self.channel))
			end
		end
	elseif self.type == TYPE_SAFETY then
		text(MENU_0, 'All Ships')
		text(MENU_1, 'Safety')
		menu(MENU_0, 'Type')
		menu(MENU_3, 'Send')
		if not valid_coast_mmsi(self.mmsi) then
			menu(MENU_2, string.format('Ch%02d', self.channel))
		end
	elseif self.type == TYPE_URGENCY then
		text(MENU_0, 'All Ships')
		text(MENU_1, 'Urgency')
		menu(MENU_0, 'Type')
		menu(MENU_3, 'Send')
		if not valid_coast_mmsi(self.mmsi) then
			menu(MENU_2, string.format('Ch%02d', self.channel))
		end
	elseif self.type == TYPE_GROUP then
		text(MENU_0, 'Group call')
		text(MENU_1, mmsi_get_group())
		menu(MENU_0, 'Type')
		menu(MENU_3, 'Send')
		if not valid_coast_mmsi(self.mmsi) then
			menu(MENU_2, string.format('Ch%02d', self.channel))
		end
	end
end
--}}}

state_dsc_call_send = {} --{{{

function state_dsc_call_send:open(data)
	self.data = data
	self.sent = false
end

function state_dsc_call_send:close()
	timer_stop(EVENT_TIMER_SEND)
	return self.data
end

function state_dsc_call_send:handle(event)
	if event == EVENT_CANCEL then
		if self.data.type == TYPE_ROUTINE_IND then
			self.data.type = TYPE_ROUTINE
		end
		return state_dsc_call
	elseif event == EVENT_ENTER then
		self.sent = true
		timer_start(EVENT_TIMER_SEND, 1200)
		view_update()
	elseif event == EVENT_TIMER_SEND then
		timer_stop(EVENT_TIMER_SEND)
		if self.data.type == TYPE_ROUTINE or self.data.type == TYPE_ROUTINE_IND then
			wait_for_ack = true
			msg_send(self.data.mmsi, self.data.channel, POWER_WATT[POWER_HI], DSC_ROUTINE, DSC_INDIVIDUAL, 0)
			view_update()
			return state_dsc_wait_ack
		else
			channel = self.data.channel
			if self.data.type == TYPE_SAFETY then
				msg_send(self.data.mmsi, self.data.channel, POWER_WATT[POWER_HI], DSC_SAFETY, DSC_ALL, 0)
			elseif self.data.type == TYPE_URGENCY then
				msg_send(self.data.mmsi, self.data.channel, POWER_WATT[POWER_HI], DSC_URGENCY, DSC_ALL, 0)
			elseif self.data.type == TYPE_GROUP then
				msg_send(self.data.mmsi, self.data.channel, POWER_WATT[POWER_HI], DSC_ROUTINE, DSC_GROUP, 0)
			end
			view_update()
			return state_rad
		end
	end
	return nil
end

function state_dsc_call_send:draw()
	bgclear()
	if self.sent then
		text(MENU_0, '    SENDING     ')
		text(MENU_2, '   DSC  CALL    ')
	else
		if self.data.type == TYPE_ROUTINE or self.data.type == TYPE_ROUTINE_IND then
			text(MENU_0, 'Routine to')
			if self.data.name then
				text(MENU_1, self.data.name)
			else
				text(MENU_1, self.data.mmsi)
			end
		elseif self.data.type == TYPE_SAFETY then
			text(MENU_0, 'All Ships')
			text(MENU_1, 'Safety')
		elseif self.data.type == TYPE_URGENCY then
			text(MENU_0, 'All Ships')
			text(MENU_1, 'Urgency')
		elseif self.data.type == TYPE_GROUP then
			text(MENU_0, 'Group call')
			text(MENU_1, self.data.mmsi)
		end
		if self.data.mmsi and not valid_coast_mmsi(self.data.mmsi) then
			text(MENU_2, string.format('On Ch%02d', self.data.channel))
		end
		text(MENU_3, 'Press E to send')
	end
end
--}}}

state_dsc_call_channel = {} --{{{

function state_dsc_call_channel:open(data)
	self.data = data
	self.first = true
	self.new_channel = self.data.channel
	self.speed_dial = 1
end

function state_dsc_call_channel:close()
	return self.data
end

function state_dsc_call_channel:handle(event)
	if is_num(event) then
		self.speed_dial = 1
		if self.first then
			self.new_channel = event
			self.first = false
		else
			self.new_channel = ((self.new_channel % 10) * 10) + event
		end
	elseif event == EVENT_SOFT_3 then
		self.new_channel = CHANNEL_SPEED_DIAL[self.speed_dial]
		self.speed_dial = (self.speed_dial + 1) % (#CHANNEL_SPEED_DIAL+1)
		if self.speed_dial == 0 then self.speed_dial = 1 end
		self.first = true
	elseif event == EVENT_ENTER then
		self.speed_dial = 1
		if valid_intership(self.new_channel) then
			self.data.channel = self.new_channel
			return state_dsc_call
		else
			snd_play(SND_BEEP_ERROR, 0)
			self.new_channel = self.data.channel
			view_update()
		end
	elseif event == EVENT_CANCEL then
		return state_dsc_call
	end
	return nil
end

function state_dsc_call_channel:draw()
	bgclear()
	chn(channel, FONT_SMALL)
	text(MENU_0, 'Reply on channel')
	text(MENU_1, string.format('%02d', self.new_channel))
	info(MENU_3, 'Rx')
	menu(MENU_3, 'Chan')
end
--}}}

state_dsc_wait_ack = {} --{{{

function state_dsc_wait_ack:open(data)
	if data and data.channel then
		channel = data.channel
	end
end

function state_dsc_wait_ack:close()
end

function state_dsc_wait_ack:handle(event)
	if event == EVENT_CANCEL or event == EVENT_SOFT_3 then
		wait_for_ack = false
		return state_rad
	elseif event == EVENT_MSG_RECV then
		local m = last_msg
		if m.dsc.mmsi == mmsi_get_ship() then
			if (m.dsc.type == DSC_ACK) then
				if (m.dsc.recv == DSC_INDIVIDUAL) then
					wait_for_ack = false
					channel = m.work_channel
					view_update()
					return state_rad
				end
			end
		end
	end
	return nil
end

function state_dsc_wait_ack:draw()
	bgclear()
	chn(channel, FONT_SMALL)
	text(MENU_0, 'Waiting for')
	text(MENU_1, 'acknowledge')
	menu(MENU_3, 'Stop')
	info(MENU_3, 'Rx')
end
--}}}

state_dsc_receive = {} --{{{

function state_dsc_receive:open()
	self.snd_map = {
		[DSC_ROUTINE] = SND_RECV_SAFETY,
		[DSC_SAFETY]  = SND_RECV_SAFETY,
		[DSC_URGENCY] = SND_RECV_URGENCY,
		[DSC_ALERT]   = SND_RECV_DISTRESS,
	}
	self.m = {}
	self.dsc_alert_page = 0
	self.stopped = false
	self.snd = -1
end

function state_dsc_receive:close()
	if self.snd >= 0 then
		snd_stop(self.snd)
	end
end

function state_dsc_receive:save_to_log()
	if #call_log >= CALL_LOG_MAX then
		table.remove(call_log, #call_log)
	end
	table.insert(call_log, 1, self.m)
end

function state_dsc_receive:handle(event)
	if event == EVENT_MSG_RECV then
		self.m = last_msg
		self.snd = self.snd_map[self.m.dsc.type]
		snd_play(self.snd, 1)
		self:save_to_log()
		view_update()
	elseif event == EVENT_SOFT_0 then
		snd_stop(self.snd)
		if self.m.dsc.recv == DSC_INDIVIDUAL and self.m.dsc.type == DSC_ROUTINE then
			msg_send(self.m.mmsi, self.m.work_channel, POWER_WATT[POWER_HI], DSC_ACK, DSC_INDIVIDUAL, 0)
		end
		channel = self.m.work_channel
		return state_rad
	elseif event == EVENT_SOFT_1 then
		snd_stop(self.snd)
		self.stopped = true
	elseif event == EVENT_SOFT_3 then
		if self.m.dsc.type == DSC_ALERT then
			if self.dsc_alert_page == 0 then
				self.dsc_alert_page = 1
			else
				self.dsc_alert_page = 0
			end
			view_update()
		end
	elseif event == EVENT_CANCEL then
		if self.m.dsc.type == DSC_ROUTINE then
			return state_rad
		end
	end
	return nil
end

function state_dsc_receive:draw()
	bgclear()
	if self.m.dsc.recv == DSC_INDIVIDUAL and self.m.dsc.type == DSC_ROUTINE then
		text(MENU_0, 'Individual')
		text(MENU_1, 'Routine')
		text(MENU_2, 'From ' .. self.m.mmsi)
		text(MENU_3, string.format('Ch%02d', self.m.work_channel))
		menu(MENU_0, 'Ack')
		if not self.stopped then
			menu(MENU_1, 'Stop')
		end
	elseif self.m.dsc.recv == DSC_GROUP and self.m.dsc.type == DSC_ROUTINE then
		text(MENU_0, 'Group call')
		text(MENU_1, 'Routine')
		text(MENU_2, 'From ' .. self.m.mmsi)
		text(MENU_3, string.format('Ch%02d', self.m.work_channel))
		menu(MENU_0, 'OK')
		if not self.stopped then
			menu(MENU_1, 'Stop')
		end
	elseif self.m.dsc.recv == DSC_ALL and self.m.dsc.type == DSC_SAFETY then
		text(MENU_0, 'All Ships')
		text(MENU_1, 'Safety')
		text(MENU_2, 'From ' .. self.m.mmsi)
		text(MENU_3, string.format('Ch%02d', self.m.work_channel))
		menu(MENU_0, 'OK')
		if not self.stopped then
			menu(MENU_1, 'Stop')
		end
	elseif self.m.dsc.recv == DSC_ALL and self.m.dsc.type == DSC_URGENCY then
		text(MENU_0, 'All Ships')
		text(MENU_1, 'Urgency')
		text(MENU_2, 'From ' .. self.m.mmsi)
		text(MENU_3, string.format('Ch%02d', self.m.work_channel))
		menu(MENU_0, 'OK')
		if not self.stopped then
			menu(MENU_1, 'Stop')
		end
	elseif self.m.dsc.recv == DSC_ALL and self.m.dsc.type ==  DSC_ALERT then
		menu(MENU_0, 'OK')
		if (self.dsc_alert_page == 0) then
			text(MENU_0, 'Distress')
			text(MENU_1, 'Alert')
			text(MENU_2, 'From ' .. self.m.mmsi)
			text(MENU_3, string.format('Ch%02d', self.m.work_channel))
			menu(MENU_3, '~')
		else
			text(MENU_0, DISTRESS_DESIGNATION[self.m.dsc.designation])
			text(MENU_1, string.sub(self.m.lat, 1, 5) .. "'" .. string.sub(self.m.lat, 8, 8))
			text(MENU_2, string.sub(self.m.lon, 1, 6) .. "'" .. string.sub(self.m.lon, 9, 9))
			text(MENU_3, string.sub(self.m.time, 12, 16) .. ' UTC')
			menu(MENU_3, '^')
		end
	end
end
--}}}

state_lcd_contrast = {} --{{{

function state_lcd_contrast:open()
end

function state_lcd_contrast:close()
end

function state_lcd_contrast:handle(event)
	if event == EVENT_CANCEL then
		return state_dsc_1
	elseif event == EVENT_SOFT_0 then
		return state_dsc_0
	elseif event == EVENT_SOFT_2 then
		if contrast < CONTRAST_MAX then
			contrast = contrast + 1
		end
	elseif event == EVENT_SOFT_3 then
		if contrast > CONTRAST_MIN then
			contrast = contrast - 1
		end
	end
	return nil
end

function state_lcd_contrast:draw()
	bgclear()
	chn(channel, FONT_SMALL)
	text(MENU_0, 'Contrast')
	if contrast == CONTRAST_MAX then
		text(MENU_1, 'MAX')
	else
		text(MENU_1, string.format('%+d', contrast))
	end
	info(MENU_3, 'Rx')
	menu(MENU_0, 'DSC')
	menu(MENU_2, '^')
	menu(MENU_3, '~')
end
--}}}

state_directory = {} --{{{

function state_directory:open()
	-- all possible sub-states within this state
	-- (hierarchical state machine, no history)
	STATE_TOP       = 0
	STATE_VIEW      = 1
	STATE_EDIT      = 2
	STATE_EDIT_NAME = 3
	STATE_EDIT_MMSI = 4
	STATE_ADD_NAME  = 5
	STATE_ADD_MMSI  = 6
	STATE_DEL       = 7

	-- state context
	self.state = STATE_TOP
	self.entry = 1
	self.enter = nil

	-- temporary data
	self.name = nil
end

function state_directory:close()
	self.enter = nil
	self.name = nil
end

function state_directory:handle(event)
	-- main menu of the directory
	if self.state == STATE_TOP then
		if event == EVENT_CANCEL then
			return state_dsc_2
		elseif event == EVENT_SOFT_0 then
			return state_dsc_0
		elseif event == EVENT_SOFT_1 and #directory > 0 then
			self.state = STATE_VIEW
		elseif event == EVENT_SOFT_2 and #directory < DIRECTORY_MAX then
			self.enter = enter_name
			self.enter:open(MENU_1, '-', '')
			self.state = STATE_ADD_NAME
		end
	-- viewing entries
	elseif self.state == STATE_VIEW then
		if event == EVENT_CANCEL then
			self.state = STATE_TOP
		elseif event == EVENT_SOFT_0 then
			return state_dsc_0
		elseif event == EVENT_SOFT_1 and self.entry > 1 then
			self.entry = self.entry - 1
			view_update()
		elseif event == EVENT_SOFT_2 and self.entry < #directory then
			self.entry = self.entry + 1
			view_update()
		elseif event == EVENT_SOFT_3 then
			self.state = STATE_EDIT
		end
	-- edit menu
	elseif self.state == STATE_EDIT then
		if event == EVENT_CANCEL then
			self.state = STATE_VIEW
		elseif event == EVENT_SOFT_0 then
			return state_dsc_0
		elseif event == EVENT_SOFT_1 then
			self.state = STATE_DEL
		elseif event == EVENT_SOFT_2 then
			self.state = STATE_EDIT_NAME
			self.enter = enter_name
			self.enter:open(MENU_1, '-', '')
		elseif event == EVENT_SOFT_3 then
			self.state = STATE_EDIT_MMSI
			self.enter = enter_mmsi
			self.enter:open(MENU_3, '-', '')
		end
	-- edit name, utilizing 'enter_name'
	elseif self.state == STATE_EDIT_NAME then
		if event == EVENT_CANCEL then
			self.enter:close()
			self.enter = nil
			self.state = STATE_EDIT
		elseif event == EVENT_SOFT_0 then
			self.enter:close()
			self.enter = nil
			return state_dsc_0
		elseif event == EVENT_SOFT_3 then
			self.enter:back()
		elseif event == EVENT_ENTER then
			if self.enter:at_start() then
				snd_play(SND_BEEP_ERROR, 0)
			else
				local name = self.enter:get_name()
				if dir_name_already_registered(name) then
					snd_play(SND_BEEP_ERROR, 0)
				else
					directory[self.entry].name = name
					dir_set(directory)
					self.enter:close()
					self.enter = nil
					self.state = STATE_EDIT
				end
			end
		elseif is_num(event) then
			self.enter:handle(event)
		elseif event == EVENT_TIMER_NEXT then
			self.enter:handle(event)
		end
	-- edit mmsi, utilizing 'enter_mmsi'
	elseif self.state == STATE_EDIT_MMSI then
		if event == EVENT_CANCEL then
			self.enter:close()
			self.enter = nil
			self.state = STATE_EDIT
		elseif event == EVENT_SOFT_0 then
			self.enter:close()
			self.enter = nil
			return state_dsc_0
		elseif event == EVENT_SOFT_3 then
			self.enter:back()
		elseif event == EVENT_ENTER then
			local mmsi = self.enter:get_mmsi()
			if valid_mmsi(mmsi) then
				directory[self.entry].mmsi = mmsi
				dir_set(directory)
				self.enter:close()
				self.enter = nil
				self.state = STATE_EDIT
			end
		elseif is_num(event) then
			self.enter:handle(event)
		end
	-- first state of adding a completely new entry.
	-- at first the name is to be entered.
	-- temporary data stored in 'self.name'
	elseif self.state == STATE_ADD_NAME then
		if event == EVENT_CANCEL then
			self.enter:close()
			self.enter = nil
			self.state = STATE_VIEW
			self.name = nil
		elseif event == EVENT_SOFT_0 then
			self.enter:close()
			self.enter = nil
			self.name = nil
			return state_dsc_0
		elseif event == EVENT_SOFT_1 and self.enter then
			self.enter:back()
		elseif event == EVENT_ENTER then
			if self.enter:at_start() then
				snd_play(SND_BEEP_ERROR, 0)
			else
				local name = self.enter:get_name()
				if dir_name_already_registered(name) then
					snd_play(SND_BEEP_ERROR, 0)
				else
					self.name = name
					self.enter:close()
					self.enter = enter_mmsi
					self.enter:open(MENU_3, '-', '')
					self.state = STATE_ADD_MMSI
				end
			end
		elseif is_num(event) then
			self.enter:handle(event)
		elseif event == EVENT_TIMER_NEXT then
			self.enter:handle(event)
		end
	-- second state of adding a new entry.
	-- this state is rechable only from STATE_ADD_NAME
	-- and adds the new entry to the directory if
	-- everything is OK.
	elseif self.state == STATE_ADD_MMSI then
		if is_num(event) then
			self.enter:handle(event)
		elseif event == EVENT_SOFT_3 then
			self.enter:back()
		elseif event == EVENT_CANCEL then
			self.enter:close()
			self.enter = nil
			self.state = STATE_VIEW
			self.name = nil
		elseif event == EVENT_SOFT_0 then
			self.enter:close()
			self.enter = nil
			self.name = nil
			return state_dsc_0
		elseif event == EVENT_ENTER then
			local mmsi = self.enter:get_mmsi()
			if valid_mmsi(mmsi) then
				directory[#directory+1] = {}
				directory[#directory].name = self.name
				directory[#directory].mmsi = mmsi
				dir_set(directory)
				self.enter:close()
				self.enter = nil
				self.state = STATE_VIEW
				self.name = nil
			else
				snd_play(SND_BEEP_ERROR, 0)
			end
		end
	-- remove an entry from the directory
	elseif self.state == STATE_DEL then
		if event == EVENT_CANCEL then
			self.state = STATE_EDIT
		elseif event == EVENT_SOFT_0 then
			return state_dsc_0
		elseif event == EVENT_SOFT_2 then
			self.state = STATE_EDIT
		elseif event == EVENT_SOFT_3 then
			table.remove(directory, self.entry)
			dir_set(directory)
			self.entry = 1
			if #directory > 0 then
				self.state = STATE_VIEW
			else
				self.state = STATE_TOP
			end
		end
	end
	return nil
end

function state_directory:draw()
	bgclear()
	if self.state == STATE_TOP then
		text(MENU_0, 'Directory')
		menu(MENU_0, 'DSC')
		if #directory < DIRECTORY_MAX then
			menu(MENU_2, 'Add')
		end
		if #directory > 0 then
			menu(MENU_1, 'View')
			text(MENU_2, 'Used ' .. string.format('%02d/%02d', #directory, DIRECTORY_MAX))
		else
			text(MENU_2, 'Empty')
		end
	elseif self.state == STATE_VIEW then
		menu(MENU_0, 'DSC')
		menu(MENU_3, 'Edit')
		if self.entry > 1 then
			menu(MENU_1, 'Back')
		end
		if self.entry < #directory then
			menu(MENU_2, 'Next')
		end
		text(MENU_0, 'Directory')
		text(MENU_1, string.format('%02d', self.entry))
		text(MENU_2, directory[self.entry].name)
		text(MENU_3, directory[self.entry].mmsi)
	elseif self.state == STATE_EDIT then
		menu(MENU_0, 'DSC')
		menu(MENU_1, 'Del')
		menu(MENU_2, '>')
		menu(MENU_3, '>')
		text(MENU_0, 'Directory')
		text(MENU_1, string.format('%02d', self.entry))
		text(MENU_2, directory[self.entry].name)
		text(MENU_3, directory[self.entry].mmsi)
	elseif self.state == STATE_EDIT_NAME then
		menu(MENU_0, 'DSC')
		text(MENU_0, 'Name:')
		text(MENU_2, 'MMSI:')
		text(MENU_3, directory[self.entry].mmsi)
		self.enter:draw()
	elseif self.state == STATE_EDIT_MMSI then
		menu(MENU_0, 'DSC')
		menu(MENU_3, '<')
		text(MENU_0, 'Name:')
		text(MENU_1, directory[self.entry].name)
		text(MENU_2, 'MMSI:')
		self.enter:draw()
	elseif self.state == STATE_ADD_NAME then
		if self.enter then
			self.enter:draw()
			text(MENU_0, 'Name:')
			menu(MENU_0, 'DSC')
			if not self.enter:at_start() then
				menu(MENU_1, '<')
			end
		end
	elseif self.state == STATE_ADD_MMSI then
		if self.enter then
			self.enter:draw()
			text(MENU_0, 'Name:')
			text(MENU_1, self.name)
			text(MENU_2, 'MMSI:')
			menu(MENU_0, 'DSC')
			if not self.enter:at_start() then
				menu(MENU_3, '<')
			end
		end
	elseif self.state == STATE_DEL then
		menu(MENU_0, 'DSC')
		menu(MENU_2, 'No')
		menu(MENU_3, 'Yes')
		text(MENU_0, 'Directory')
		text(MENU_1, 'Delete ?')
		text(MENU_2, directory[self.entry].name)
		text(MENU_3, directory[self.entry].mmsi)
	end
end
--}}}

state_call_log = {} --{{{

-- Shows and browses the call log if there were incoming
-- calls in the past (since the simulator was started).
-- See 'state_dsc_receive' for the maximum number of log
-- entries.

function state_call_log:open()
	self.entry = 1
	self.alert_screen = 0
end

function state_call_log:close()
end

function state_call_log:handle(event)
	if event == EVENT_CANCEL then
		return state_dsc_0
	elseif event == EVENT_SOFT_0 then
		return state_dsc_0
	elseif event == EVENT_SOFT_1 and self.entry < #call_log then
		self.entry = self.entry + 1
		view_update()
	elseif event == EVENT_SOFT_2 and self.entry > 1 then
		self.entry = self.entry - 1
		view_update()
	elseif event == EVENT_SOFT_3 and call_log[self.entry].dsc.type == DSC_ALERT then
		if self.alert_screen == 0 then
			self.alert_screen = 1
		else
			self.alert_screen = 0
		end
		view_update()
	end
	return nil
end

function state_call_log:draw()
	bgclear()
	menu(MENU_0, 'DSC')
	if #call_log > 1 then
		if self.entry > 1 then
			menu(MENU_2, 'Next')
		end
		if self.entry < #call_log then
			menu(MENU_1, 'Back')
		end
	end
	local m = call_log[self.entry]
	if m.dsc.type == DSC_ALERT then
		if self.alert_screen == 0 then
			menu(MENU_3, '~')
			text(MENU_0, 'Distress')
			text(MENU_1, 'Alert')
			text(MENU_2, 'From')
			text(MENU_3, m.mmsi)
		else
			menu(MENU_3, '^')
			text(MENU_0, DISTRESS_DESIGNATION[m.dsc.designation])
			text(MENU_1, string.sub(m.lat, 1, 5) .. "'" .. string.sub(m.lat, 8, 8))
			text(MENU_2, string.sub(m.lon, 1, 6) .. "'" .. string.sub(m.lon, 9, 9))
			text(MENU_3, string.sub(m.time, 12, 16) .. ' UTC')
		end
	else
		if m.dsc.recv == DSC_INDIVIDUAL then
			text(MENU_0, 'Individual')
		elseif m.dsc.recv == DSC_GROUP then
			text(MENU_0, 'Group')
		elseif m.dsc.recv == DSC_ALL then
			text(MENU_0, 'All Ships')
		end
		if m.dsc.type == DSC_ROUTINE then
			text(MENU_1, 'Routine')
		elseif m.dsc.type == DSC_SAFETY then
			text(MENU_1, 'Safety')
		elseif m.dsc.type == DSC_URGENCY then
			text(MENU_1, 'Urgency')
		end
		text(MENU_2, 'From')
		text(MENU_3, m.mmsi)
	end
end
--}}}

-- STATE MACHINE AND INITIALIZATION

-- STATE MACHINE {{{
state = nil

function state_change_to(new_state)
	if new_state then
		local data = state:close()
		state = new_state
		state:open(data)
	end
end

function event(id)

	-- ignore invalid events
	if id == -1 then return -1 end

	-- handle key beeps
	if beep_enable and is_turned_on() then
		if contains(BEEP_EVENTS, id) then
			snd_play(SND_BEEP_KEY, 0)
		end
	end

	-- handle distress button (mechanical part)
	if id == EVENT_DISTRESS_RELEASE and not handling_distress then
		if da_open == false then
			da_open = true
			view_update()
			return 0
		elseif da_open == true and is_turned_on() then
			-- changing to state_send_distress is handled globally
			-- to be able to enter this menu if pressing the
			-- distress alert button. the new state will temporarily
			-- take control over the distress events (see handling_distress).
			state_change_to(state_send_distress)
			view_update()
			return 0
		end
	elseif id == EVENT_DISTRESS_CLOSE_RELEASE and not handling_distress then
		da_open = false
		view_update()
		return 0
	end

	-- handle turning off the device
	if id == EVENT_VOLUME_DOWN then
		-- volume down
		if volume > VOLUME_OFF then
			volume = volume - 1
			handle_volume()
			handle_squelch()
		end
		if is_turned_off() then
			timer_stop(EVENT_TIMER_GPS)
			state_change_to(state_off)
		end
	elseif id == EVENT_VOLUME_UP then
		-- volume up
		if volume < VOLUME_MAX then
			volume = volume + 1
			handle_volume()
			handle_squelch()
		end
	end

	-- handle squelch
	if id == EVENT_SQUELCH_DOWN then
		-- squelch down
		if squelch > SQUELCH_MIN then
			squelch = squelch - 1
			handle_squelch()
		end
	elseif id == EVENT_SQUELCH_UP then
		-- squelch up
		if squelch < SQUELCH_MAX then
			squelch = squelch + 1
			handle_squelch()
		end
	end

	-- handle emergency frequency button
	if is_turned_on() and id == EVENT_EMERGENCYFREQ then
		set_emerg_ch()
		state_change_to(state_rad)
	end

	-- handle incoming calls
	if id == EVENT_MSG_RECV then
		local m = receive_msg()
		if is_turned_on() then
			-- check for MMSI, Group MMSI or calls to ALL STATIONS
			-- ignore all calls not targetting this VHF
			if i_am_receiver_of(m) then
				last_msg = m
				if not wait_for_ack then
					if m.dsc.type ~= DSC_ACK then
						-- do not handle unexpected ACKs
						state_change_to(state_dsc_receive)
						-- let new state handle the event as usual
					end
				end
			else
				-- received a message not targeted at this VHF
				-- therefore the message is ignored an no
				-- state is informed
				return -1
			end
		else
			-- turned off, ignore message
			return -1
		end
	end

	-- handle light events
	if is_turned_on() then
		if id == EVENT_LIGHT_PRESS then
			if light == LIGHT_OFF then
				light = LIGHT_MIN
				timer_start(EVENT_TIMER_LIGHT, 500)
				view_update()
			else
				light = LIGHT_OFF
			end
		elseif id == EVENT_LIGHT_RELEASE then
			timer_stop(EVENT_TIMER_LIGHT)
			view_update()
		elseif id == EVENT_TIMER_LIGHT then
			if light < LIGHT_MAX then
				light = light + 1
			end
			timer_start(EVENT_TIMER_LIGHT, 500)
			view_update()
		end
	end

	-- handle GPS events
	if is_turned_on() and (id == EVENT_GPS) then
		-- sync position and time with GPS, data is already in model,
		-- just update the view and the data is taken from model

		-- (re)start GPS timeout timer
		timer_start(EVENT_TIMER_GPS, GPS_TIMEOUT)
		gps_available = true

		-- GPS events cannot be handled by a specific state
		-- therefore update view and return
		view_update()
		return 0
	end
	if is_turned_on() and (id == EVENT_TIMER_GPS) then
		-- GPS data is out of date
		timer_stop(EVENT_TIMER_GPS)
		gps_available = false

		-- GPS events cannot be handled by a specific state
		-- therefore update view and return
		view_update()
		return 0
	end

	-- finally, let the state handle the event
	local new_state = state:handle(id)
	state_change_to(new_state)
	return 0
end

function draw()
	if state then
		state:draw()
		draw_da_open() -- open distress alert button
	end
end

function exam_mode(mode)
	in_exam_mode = mode
end

--}}}

-- INITIALZATION {{{
function init_keys()
	bind_key('0', EVENT_0, -1)
	bind_key('1', EVENT_1, -1)
	bind_key('2', EVENT_2, -1)
	bind_key('3', EVENT_3, -1)
	bind_key('4', EVENT_4, -1)
	bind_key('5', EVENT_5, -1)
	bind_key('6', EVENT_6, -1)
	bind_key('7', EVENT_7, -1)
	bind_key('8', EVENT_8, -1)
	bind_key('9', EVENT_9, -1)
	bind_key('ENTER', EVENT_ENTER, -1)
	bind_key('ESC', EVENT_CANCEL, -1)
	bind_key('F1', EVENT_SOFT_0, -1)
	bind_key('F2', EVENT_SOFT_1, -1)
	bind_key('F3', EVENT_SOFT_2, -1)
	bind_key('F4', EVENT_SOFT_3, -1)
end

function init_buttons()
	-- volume
	bind_btn_rect(555, 20, 590, 80, MOUSE_LEFT, EVENT_VOLUME_UP, -1)
	bind_btn_rect(520, 20, 555, 80, MOUSE_LEFT, EVENT_VOLUME_DOWN, -1)

	-- squelch
	bind_btn_rect(555, 210, 590, 270, MOUSE_LEFT, EVENT_SQUELCH_DOWN, -1)
	bind_btn_rect(520, 210, 555, 270, MOUSE_LEFT, EVENT_SQUELCH_UP, -1)

	-- distress alert
	bind_btn_rect(500, 100, 555, 187, MOUSE_LEFT, EVENT_DISTRESS_PRESS, EVENT_DISTRESS_RELEASE)
	bind_btn_rect(555, 100, 630, 187, MOUSE_LEFT, EVENT_DISTRESS_CLOSE_PRESS, EVENT_DISTRESS_CLOSE_RELEASE)

	-- soft buttons
	bind_btn_circle(318,  30, 15, MOUSE_LEFT, EVENT_SOFT_0, -1)
	bind_btn_circle(318,  92, 15, MOUSE_LEFT, EVENT_SOFT_1, -1)
	bind_btn_circle(318, 153, 15, MOUSE_LEFT, EVENT_SOFT_2, -1)
	bind_btn_circle(318, 214, 15, MOUSE_LEFT, EVENT_SOFT_3, -1)

	-- special buttons
	bind_btn_circle(278, 247, 17, MOUSE_LEFT, EVENT_LIGHT_PRESS, EVENT_LIGHT_RELEASE)
	bind_btn_circle(205, 247, 17, MOUSE_LEFT, EVENT_TOGGLEPOWER, -1)
	bind_btn_circle(231, 199, 17, MOUSE_LEFT, EVENT_DUALWATCH, -1)
	bind_btn_circle(158, 199, 17, MOUSE_LEFT, EVENT_EMERGENCYFREQ, -1)

	-- buttons (numeric, cancel, enter, ...)
	bind_btn_circle(371,  64, 17, MOUSE_LEFT, EVENT_1, -1)
	bind_btn_circle(421,  64, 17, MOUSE_LEFT, EVENT_2, -1)
	bind_btn_circle(473,  64, 17, MOUSE_LEFT, EVENT_3, -1)
	bind_btn_circle(371, 125, 17, MOUSE_LEFT, EVENT_4, -1)
	bind_btn_circle(421, 125, 17, MOUSE_LEFT, EVENT_5, -1)
	bind_btn_circle(473, 125, 17, MOUSE_LEFT, EVENT_6, -1)
	bind_btn_circle(371, 186, 17, MOUSE_LEFT, EVENT_7, -1)
	bind_btn_circle(421, 186, 17, MOUSE_LEFT, EVENT_8, -1)
	bind_btn_circle(473, 186, 17, MOUSE_LEFT, EVENT_9, -1)
	bind_btn_circle(371, 246, 17, MOUSE_LEFT, EVENT_CANCEL, -1)
	bind_btn_circle(421, 246, 17, MOUSE_LEFT, EVENT_0, -1)
	bind_btn_circle(473, 246, 17, MOUSE_LEFT, EVENT_ENTER, -1)
end

function main_size()
	return img_get_size(0)
end

function init_images()
	-- images
	img_load(0, 'vhf.bmp')
	img_load(1, 'vhf-da.bmp')
	lcd.x0 =  60
	lcd.y0 =  29
	lcd.x1 = 256
	lcd.y1 = 140
	lcd.w  = lcd.x1 - lcd.x0 + 1
	lcd.h  = lcd.y1 - lcd.y0 + 1
	lcd.b  = 2
	lcd.npx = 100
	lcd.npy = 54
	lcd.pw = 2
	lcd.ph = 2

	-- volume button
	mark_vol.x = 557
	mark_vol.y =  48
	mark_vol.r =  20
	mark_vol.phi_min = 225
	mark_vol.phi_max = 135
	mark_vol.radius = 5
	mark_vol.dir = 1

	-- squelch button
	mark_sq.x = 555
	mark_sq.y = 249
	mark_sq.r =  20
	mark_sq.phi_min = 225
	mark_sq.phi_max = 135
	mark_sq.radius = 5
	mark_sq.dir = -1
end

function init_sounds()
	if snd_init(NUM_SOUNDS) == false then
		print('ERROR: CANNOT INIT SOUND')
		return
	end
	snd_load_wav(SND_BEEP1,         'beep1.wav')
	snd_load_wav(SND_BEEP2,         'beep2.wav')
	snd_load_wav(SND_BEEP3,         'beep3.wav')
	snd_load_wav(SND_BEEP4,         'beep4.wav')
	snd_load_wav(SND_BEEP5,         'beep5.wav')
	snd_load_wav(SND_BEEP1S,        'beep1s.wav')
	snd_load_wav(SND_DISTRESS,      'distress.wav')
	snd_load_wav(SND_SQUELCH,       'squelch.wav')
	snd_load_wav(SND_RECV_SAFETY,   'recv-safety.wav')
	snd_load_wav(SND_RECV_URGENCY,  'recv-urgency.wav')
	snd_load_wav(SND_RECV_DISTRESS, 'recv-distress.wav')
	snd_load_wav(SND_BEEP_KEY,      'beep1.wav')
	snd_load_wav(SND_BEEP_ERROR,    'beep5.wav')

	-- define constant gains for some sounds. those
	-- sounds are not dependant on the volume setting.
	snd_gain(SND_BEEP_KEY, VOLUME_KEY)
	snd_gain(SND_BEEP_ERROR, VOLUME_ERROR)
end

function init_backgrounds()
	background[0] = {  0,  80,  12, } -- LIGHT_OFF
	background[1] = { 92, 172, 108, } -- LIGHT_MIN
	background[2] = { 92, 195, 108, }
	background[3] = { 92, 215, 108, }
	background[4] = { 92, 235, 108, }
	background[5] = { 92, 255, 108, } -- LIGHT_MAX
end

function init_foregrounds()
	foreground[0] = { 60,  60,  60, } -- CONTRAST_MIN
	foreground[1] = { 50,  50,  50, }
	foreground[2] = { 40,  40,  40, }
	foreground[3] = { 30,  30,  30, }
	foreground[4] = { 20,  20,  20, }
	foreground[5] = { 10,  10,  10, }
	foreground[6] = {  5,   5,   5, }
	foreground[7] = {  0,   0,   0, } -- CONTRAST_MAX
end

function init_timers()
	timer_create(EVENT_TIMER)
	timer_create(EVENT_TIMER_GPS)
	timer_create(EVENT_TIMER_SEND)
	timer_create(EVENT_TIMER_LIGHT)
	timer_create(EVENT_TIMER_NEXT)
end

function init_events()
	bind_gps(EVENT_GPS)
	bind_msg(EVENT_MSG_RECV)
end

function init_bitmaps()
	for f,t in pairs(FONT) do
		for id,c in pairs(t) do
			bitmap_register('N-' .. f .. '-' .. id, c.w, c.h, '#', c.d)
			local inv = invert_letter(c)
			bitmap_register('I-' .. f .. '-' .. id, inv.w, inv.h, '#', inv.d)
		end
	end
end

function init()
	-- configure system
	init_keys()
	init_buttons()
	init_images()
	init_sounds()
	init_foregrounds()
	init_backgrounds()
	init_timers()
	init_events()
	init_bitmaps()

	-- init data
	directory = dir_get()

	-- init state machine
	state = state_off
	state:open()
	event(-1)
end

init()
--}}}

